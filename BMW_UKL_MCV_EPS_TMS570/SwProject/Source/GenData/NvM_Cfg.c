/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2010 by Vctr Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vctr Informatik GmbH.
 *                Vctr Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vctr Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  NvM_Cfg.c
 *      Project:  MemService_AsrNvM
 *       Module:  NvM - Submodule Cfg (configuration)
 *    Generator:  -
 *
 *  Description:  Configuration objects (Link-Time)
 *
 *  -------------------------------------------------------------------------------------------------------------------
 *  GENERATION INFORMATION
 *  -------------------------------------------------------------------------------------------------------------------
 *     Project:    EPS.ecuc
 *   Generated:  2016-06-08 10:59 am
 *    Licensee:   Nxtr Automotive Corporation (2502600608)
 
    This file is generated by DaVinci Configurator Pro - DAVINCICFG.EXE V4.0.67.0.
    Do not modify this file, otherwise the software may behave in unexpected way.
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  MODULE SWITCH
 *********************************************************************************************************************/
/* this switch enables the header file(s) to hide some parts. */
#define NVM_CONFIGURATION

/* Disable declaration of API in NvM.h, as it would collide with declaration in Rte_NvM.h          *
 * From NvM.h we just need the version info as well as the inclusion of NvM_Cfg.h                  */
#define NVM_SKIP_API_DECLARATIONS STD_ON

/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/
#include "Std_Types.h"

/* Define RTE_MICROSAR_PIM_EXPORT is necessary only when serviceports are used */
#define RTE_MICROSAR_PIM_EXPORT

/**********************************************************************************************************************
 *  MODULE HEADER INCLUDES
 *********************************************************************************************************************/
/* only includes the public part of config */
#include "NvM.h"
#include "NvM_PrivateCfg.h"

#include "NvM_Crc.h"

/* This tag will only be replaced, if one or more callbacks via Service Ports had been configured */
/*<NVM_SERVICE_PORTS_INCLUDE/>*/

/**********************************************************************************************************************
 *  VERSION CHECKS
 *********************************************************************************************************************/
#if (     (NVM_CFG_MAJOR_VERSION != (3u)) \
       || (NVM_CFG_MINOR_VERSION != (7u)))
  #error "Version numbers of NvM_Cfg.c and NvM_Cfg.h are inconsistent!"
#endif

#if (     (NVM_PRIV_CFG_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_PRIV_CFG_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM_Cfg.h are inconsistent!"
#endif

#if ((NVM_SW_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_SW_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM.h are inconsistent!"
#endif

#if ((NVM_TYPES_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_TYPES_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM_Types.h are inconsistent!"
#endif

#include "Crc.h" /* always needed, since the config Block has a CRC */

/**** AUTOSAR Version Checks *********/

#if defined(CRC_VENDOR_ID)
#   if ((CRC_VENDOR_ID == NVM_VENDOR_ID) && \
        ((CRC_AR_MAJOR_VERSION != 3u) || (CRC_AR_MINOR_VERSION != 1)) && \
        ((CRC_AR_MAJOR_VERSION != 3u) || (CRC_AR_MINOR_VERSION != 0)) && \
        ((CRC_AR_MAJOR_VERSION != 2u) || (CRC_AR_MINOR_VERSION != 1)))
#       error "AUTOSAR Version of CRC module is not supported!"
#   endif
#endif

#if defined(MEMIF_VENDOR_ID)
#   if ((MEMIF_VENDOR_ID == NVM_VENDOR_ID) && \
        ((MEMIF_AR_MAJOR_VERSION != 1u) || (MEMIF_AR_MINOR_VERSION != 1)) && \
        ((MEMIF_AR_MAJOR_VERSION != 1u) || (MEMIF_AR_MINOR_VERSION != 2)))
#       error "AUTOSAR Version of MemIf module is not supported!"
#   endif
#endif

#if defined(DEM_VENDOR_ID)
#   if ((DEM_VENDOR_ID == NVM_VENDOR_ID) && \
        ((DEM_AR_MAJOR_VERSION != 2u) || (DEM_AR_MINOR_VERSION != 2)) && \
        ((DEM_AR_MAJOR_VERSION != 3u) || (DEM_AR_MINOR_VERSION != 1)))
#       error "AUTOSAR Version of DEM module is not supported!"
#   endif
#endif

/* check, if NvM has to declare PIM externals on its own */
#if (STD_ON == NVM_RTE_INCLUDED)
	#if (defined RTE_VENDOR_ID)
		#if (RTE_VENDOR_ID == (0x001Eu))
			#if ((RTE_SW_MAJOR_VERSION < 2) || ((RTE_SW_MAJOR_VERSION == 2) && (RTE_SW_MINOR_VERSION < 12)))
				#define NVM_USE_PIM_EXTERNALS
			#endif
		#else
			# define NVM_USE_PIM_EXTERNALS
		#endif
	#else
		#define NVM_USE_PIM_EXTERNALS
	#endif
#endif

/* include list of the callback definitions */
/*<NVM_CFG_CBK_INCLUDE_LIST>*/
#include "ApplMain.h"
#include "Cdc.h"
#include "sc_ee_data.h"
#include "Darh.h"
#include "Vsm_Client.h"
#include "Coding.h"
#include "EcuM_Cbk.h"
#include "CDD_Data.h"
#include "ApplCallbacks.h"
#include "Cd_NvMProxy.h"
#include "Ap_DfltConfigData.h"
#include "Swt_SWData.h"
#include "Ap_DiagMgr.h"
#include "Ap_StaMd_Cfg.h"
#include "Ap_VehCfg.h"
#include "Cd_TcFlshPrg.h"
#include "Edch_NvM.h"
/*</NVM_CFG_CBK_INCLUDE_LIST>*/

/* include configured file declaring or defining resource (un)locking service(s) */

#include "SchM_NvM.h"


#define NVM_SIZE_STANDARD_JOB_QUEUE     /*<NVM_SIZE_STANDARD_QUEUE/>*/ (16u)
#define NVM_SIZE_IMMEDIATE_JOB_QUEUE    /*<NVM_SIZE_IMMEDIATE_QUEUE/>*/ 0u

/* Just for your information:
 * NVRAM Blocks with CRC: 13
*/
/* the size of the CRC job queue in 32bitWords. It is a bit-string, one bit for each block */
#define NVM_SIZE_CRC_JOB_QUEUE ((NVM_TOTAL_NUM_OF_NVRAM_BLOCKS * 2 + NVM_CRC_QUEUE_BITINDEX_MASK) >> \
                                                                            NVM_CRC_QUEUE_ENTRY_SHIFT)

#define NVM_CFG_CHECK_RAM_BLOCK_LENGTHS /*<NVM_CFG_CHECK_RAM_BLOCK_LENGTHS/>*/ (STD_OFF)
#define NVM_CFG_CHECK_ROM_BLOCK_LENGTHS /*<NVM_CFG_CHECK_ROM_BLOCK_LENGTHS/>*/ (STD_OFF)

#define NVM_USE_CRC16 STD_ON
#define NVM_USE_CRC32 STD_OFF /* No Crc32 used */

/* initial crc value */
#define NVM_INITIAL_CRC_16_VALUE    0xFFFFu
#define NVM_INITIAL_CRC_32_VALUE    (0xFFFFFFFFuL ^ NVM_CRC32_XOR_VALUE)

#define NVM_CRC32_XOR_VALUE     0xFFFFFFFFu


#define NVM_START_SEC_CODE
#include "MemMap.h"

#if(NVM_USE_CRC16 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc16_Calculate(NvM_ConstRamAddressType, uint16, NvM_CrcValuePtrType);
    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc16_Compare      (NvM_CrcBufferConstPtrType, NvM_CrcValueRefType);
    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc16_CopyToBuffer (NvM_CrcBufferPtrType, NvM_CrcValueRefType);
#endif

#if(NVM_USE_CRC32 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc32_Calculate(NvM_ConstRamAddressType, uint16, NvM_CrcValuePtrType);
    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc32_Compare      (NvM_CrcBufferConstPtrType, NvM_CrcValueRefType);
    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc32_CopyToBuffer (NvM_CrcBufferPtrType, NvM_CrcValueRefType);
#endif

/*<NVM_CFG_BLOCK_INT_CBK_DECL/>*/


#define NVM_STOP_SEC_CODE
#include "MemMap.h"

/**********************************************************************************************************************
 *  PUBLIC CONSTANTS
 *********************************************************************************************************************/

#define NVM_START_SEC_CONST_8BIT
#include "MemMap.h"

    /* Number of write attempts: 1 + number of retries */
    CONST(uint8, NVM_PRIVATE_CONST) NvM_NoOfWrAttempts_u8 = 3u;

#define NVM_STOP_SEC_CONST_8BIT
#include "MemMap.h"


#define NVM_START_SEC_CONST_16BIT
#include "MemMap.h"

    /* maximum number of bytes to be processed in one crc calculation step */
    CONST(uint16, NVM_CONFIG_CONST) NvM_NoOfCrcBytes_u16 = 65535u;

	/* constant holding Crc quueue size value */
	CONST(uint16, NVM_PRIVATE_CONST) NvM_CrcQueueSize_u16 = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS * 2;

#define NVM_STOP_SEC_CONST_16BIT
#include "MemMap.h"

/* close section, to ensure unique section ends */
#define NVM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"
    /* constants holding the compiled queue size values */
    CONST(NvM_QueueSizesType, NVM_PRIVATE_CONST) NvM_QueueSizes_t =
    {
        /* MISRA wants to define a operator precedence with parentheses */
        (NVM_SIZE_STANDARD_JOB_QUEUE + NVM_SIZE_IMMEDIATE_JOB_QUEUE) - 1u,
        NVM_SIZE_STANDARD_JOB_QUEUE
    };

#if(NVM_USE_CRC16 == STD_ON)
    static CONST(struct NvM_CrcHandlerClass, NVM_PRIVATE_CONST) NvM_Crc_Crc16Handler_t =
    {
        NvM_Crc_Crc16_Calculate,
        NvM_Crc_Crc16_Compare,
        NvM_Crc_Crc16_CopyToBuffer,
        NVM_INITIAL_CRC_16_VALUE, /* initial value */
        2  /* crc length */
    };
#else
#   define NvM_Crc_Crc16Handler_t NvM_Crc_NoCrcHandler_t
#endif

#if(NVM_USE_CRC32 == STD_ON)
static CONST(struct NvM_CrcHandlerClass, NVM_PRIVATE_CONST) NvM_Crc_Crc32Handler_t =
{
    NvM_Crc_Crc32_Calculate,
    NvM_Crc_Crc32_Compare,
    NvM_Crc_Crc32_CopyToBuffer,
    NVM_INITIAL_CRC_32_VALUE, /* initial value */
    4  /* crc length */
};
#else
#   define NvM_Crc_Crc32Handler_t NvM_Crc_NoCrcHandler_t
#endif

    CONST(NvM_CrcHandlerClassConstPtr, NVM_PRIVATE_CONST) NvM_CrcHandlerTable_at[4] =
    {
        &NvM_Crc_NoCrcHandler_t,
        &NvM_Crc_NoCrcHandler_t, /* reserved for CRC8 */
        &NvM_Crc_Crc16Handler_t,
        &NvM_Crc_Crc32Handler_t
    };

    /* Constants, holding the two DEM error codes, defined by DEM */

    CONST(Dem_EventIdType, NVM_PRIVATE_CONST) NvM_DemErrReqFailed       = NVM_E_REQ_FAILED;
    CONST(Dem_EventIdType, NVM_PRIVATE_CONST) NvM_DemErrIntegrityFailed = NVM_E_INTEGRITY_FAILED;


/* close section, to ensure unique section ends */
#define NVM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/* 8Bit Data section containing the CRC buffers, as well as the internal buffer */
#define NVM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"

static VAR(uint8, NVM_PRIVATE_DATA) ConfigBlock_RamBlock_au8[2];

#if(STD_ON == NVM_CRC_INT_BUFFER)

static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_CODING_STATUS_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_CDC_DATA_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_DARH_DATA_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_DEM_STATUS_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) Rte_NvmBlock_MtrPos_MtrPosSnsr_EOLData_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) Rte_NvmBlock_Polarity_EOLCtrlPolarity_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) Rte_NvmBlock_HwTrq_HwTrqTrimData_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_EPSDEFEATS_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_DEM_PRIMARY_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_DEM_SECONDARY_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) Rte_NvmBlock_AbsHwPos_Trim_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_CODING_DATA_Crc_au8[2];


/* create the internal buffer of size NVM_INTERNAL_BUFFER_SIZE */
VAR(uint8, NVM_PRIVATE_DATA) NvM_InternalBuffer_au8[314];
#endif

/* create a test buffer of size 1 byte for testing readability of a block */
VAR(uint8, NVM_PRIVATE_DATA) NvM_TestBuffer_u8;

#define NVM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"


#if (defined NVM_USE_PIM_EXTERNALS)
/* Declare RAM Block symbols, provided by RTE (PIMs)
*  Note that these declarations are located intentionally outside any MemMap section.
*/



extern VAR(uint8, NVM_APPL_DATA) Coding_NvStatus[];
extern CONST(uint8, NVM_APPL_CONST) Coding_NvStatusDefaults[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_Polarity_k_SystemPolarity_Cnt_b16[];
extern VAR(uint8, NVM_APPL_DATA) NTCStrgArray_Cnt_str[];
extern VAR(uint8, NVM_APPL_DATA) CDD_EOLSrlComSvcDft_Cnt_G_b32[];
extern CONST(uint8, NVM_APPL_CONST) T_InitEPSDefeats_Cnt_u32[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_ParamComp_EOLNomMtrParam[];
extern VAR(uint8, NVM_APPL_DATA) TypeHData_Cnt_u08[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_LrnEOT_LearnedEOT[];
extern CONST(uint8, NVM_APPL_CONST) T_InitLearnedEOT[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_NMEC_Cnt_u8[];
extern CONST(uint8, NVM_APPL_CONST) T_InitNMEC_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EcuSrlNum_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EpsSrlNum_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EcuHwPn_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_NxtrManfScrpd_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_IgnCntr_Cnt_u16[];
extern VAR(uint8, NVM_APPL_DATA) Rte_LnRkCr_LearnedRackCntr[];
extern CONST(uint8, NVM_APPL_CONST) T_InitLnRkCtr_RackCntrData[];
extern VAR(uint8, NVM_APPL_DATA) Rte_AbsHwPos_EOLHwOffsetSnsrCal[];
extern VAR(uint8, NVM_APPL_DATA) Rte_VehCfg_PrevVldTuningSel[];
extern VAR(uint8, NVM_APPL_DATA) NTCBlackBoxData_Cnt_str[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_CloseCheck_Cnt_u32[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_AbsHwPos_Trim[];
extern CONST(uint8, NVM_APPL_CONST) T_InitAbsHwPos_Trim[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_TurnsCounter_EOLTurnsCntrCals[];
extern VAR(uint8, NVM_APPL_DATA) HwDescData[];
extern VAR(uint8, NVM_APPL_DATA) Rte_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal[];
extern VAR(uint8, NVM_APPL_DATA) TcFlshDataNvm_Uls_str[];
extern VAR(uint8, NVM_APPL_DATA) Edch_CalId_val[];
extern CONST(uint8, NVM_APPL_CONST) Edch_CalIdDefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Edch_Cvn_val[];
extern CONST(uint8, NVM_APPL_CONST) Edch_CvnDefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Edch_OperationCycleState[];
extern CONST(uint8, NVM_APPL_CONST) Edch_OperationCycleStateDefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Edch_SubCvn_0_val[];
extern CONST(uint8, NVM_APPL_CONST) Edch_SubCvn_0_DefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Edch_SubCvn_1_val[];
extern CONST(uint8, NVM_APPL_CONST) Edch_SubCvn_1_DefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Edch_SubCvn_2_val[];
extern CONST(uint8, NVM_APPL_CONST) Edch_SubCvn_2_DefaultVal[];
extern VAR(uint8, NVM_APPL_DATA) Nxtr_FeeInitialized_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) SvkHistoryMemory[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_MtrSuplrByte_Cnt_u8[];
extern CONST(uint8, NVM_APPL_CONST) T_MtrSuplrService_Data[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_ElecHwIndex_Cnt_u16[];
extern VAR(uint8, NVM_APPL_DATA) Rte_AvgFricLrn_AvgFricLrnData[];
extern VAR(uint8, NVM_APPL_DATA) Coding_NvData[];
extern CONST(uint8, NVM_APPL_CONST) Coding_NvDataDefaults[];
extern VAR(uint8, NVM_APPL_DATA) Rte_ActivePull_PullCmpLTComp_HwNm_f32[];

#endif

#define NVM_START_SEC_CONST_DESCRIPTOR_TABLE
#include "MemMap.h"

    CONST(NvM_BlockIdType, NVM_PUBLIC_CONST) NvM_NoOfBlockIds_t = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS;

    CONST(NvM_CompiledConfigIdType, NVM_PUBLIC_CONST) NvM_CompiledConfigId_t = {(uint16)NVM_COMPILED_CONFIG_ID};


    /* define the multi block callback */
    CONST(NvM_MultiCbkPtrType, NVM_CONFIG_CONST) NvM_MultiBlockCbk = /*<NVM_MULTIBLOCK_CALLBACK/>*/ EcuM_CB_NfyNvMJobEnd;

    /* NvM_MultiBlockCbk(ServiceId, RequestResult) */

    /* block descriptor table that holds the static configuration parameters of the RAM, ROM and NVBlocks.
     * This table has to be adjusted according to the configuration of the NVManager.
     */
    CONST(NvM_BlockDescriptorType, NVM_CONFIG_CONST) NvM_BlockDescriptorTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        {   /* block descriptor for multiblock calls. This block id is
             * reserved as it is used to access the result of multiblock
             * requests. This block descriptor entry will not be used.
             */
            NULL_PTR,           /* pointer to the RAM data buffer */
            NULL_PTR,           /* pointer to the ROM default data block */

            NULL_PTR, /* pointer to the job End Callback function */
#if(STD_ON == NVM_CRC_INT_BUFFER)
            NULL_PTR,       	/* pointer to the CRC data buffer */
#endif
            1u,                 /* NvIdentifier dummy */
            0u,                 /* Length of the block in bytes */
            0u,                 /* Number of multiple blocks (depends on Mngmt type), don't care */
            0xFFu,              /* block write priorisation */
            0u,                 /* device id */
            NVM_BLOCK_NATIVE,   /* Management Type */
            NVM_BLOCK_USE_CRC_OFF, /* no CRC; don't care */
            0u,                 /* flags, don't care */
            0u                  /* default_pt is ROM Default block -> don't care */
        },
        {
            /*<NVM_CONFIG_BLOCK_DESCRIPTOR/>*/     
        /* block descriptor Config Id Block block ConfigBlock */
        (NvM_RamAddressType)ConfigBlock_RamBlock_au8,    /* pointer to the RAM data buffer */
        NULL_PTR,    /* No ROM default data block */
        NULL_PTR,    /* pointer to the Job End Callback function */
        NULL_PTR,    /* pointer to the CRC buffer */
        0x0020u,    /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        2u,    /* Number of multiple blocks */
        127u,    /* Block Priority */
        MEMIF_Fee,                                /* Device Id (defined by MemIf) */
        NVM_BLOCK_REDUNDANT,    /* Management Type */
    NVM_BLOCK_CRC_16_ON,    /* CRC16 */
        (
            NVM_CALC_RAM_BLOCK_CRC_OFF |            /* Calc CRC on NvM_SetRamBlockStatus() */
            NVM_BLOCK_WRITE_PROT_OFF |            /* Initial write protection */
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |        /* Write Block once */
            NVM_RESISTANT_TO_CHANGED_SW_ON |        /* Resistant to Changed SW */
            NVM_SELECT_BLOCK_FOR_READALL_ON        /* Select this block for NvM_ReadAll() */
        ),
            0        /* Is ROM DefaultBlock -> irrelevant, since we don't have any default data */

        }

        /*<NVM_DESCRIPTOR_TABLE_CONFIG>*/
    
    /* block descriptor user block NVM_BLOCK_BOOT_PROG_STATUS */
    ,{
        (NvM_RamAddressType)&BootProgStatus /* pointer to the RAM data buffer */,
        Init_BootProgStatus,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0040u,     /* NV block Base number (defined by FEE/EA) */
        6u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_VSMOMC_DATA */
    ,{
        (NvM_RamAddressType)&Vsm_OmcNvData /* pointer to the RAM data buffer */,
        &Vsm_OmcNvData_Default /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x00A0u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_BOOT_PROG_COUNTER */
    ,{
        (NvM_RamAddressType)&BootProgCounter /* pointer to the RAM data buffer */,
        Init_BootProgCounter,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0060u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_BOOT_PROG_DATA */
    ,{
        (NvM_RamAddressType)&BootProgData /* pointer to the RAM data buffer */,
        Init_BootProgData,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0080u,     /* NV block Base number (defined by FEE/EA) */
        47u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_NVM_BLOCK_CODING_DATA */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0160u,     /* NV block Base number (defined by FEE/EA) */
        155u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_ON |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CODING_STATUS */
    ,{
        (NvM_RamAddressType)&Coding_NvStatus /* pointer to the RAM data buffer */,
        &Coding_NvStatusDefaults /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_CODING_STATUS_Crc_au8, /* Pointer to the CRC buffer */
        0x0180u,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CDC_DATA */
    ,{
        (NvM_RamAddressType)&Cdc_NvData /* pointer to the RAM data buffer */,
        &Cdc_NvDataDefault /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_CDC_DATA_Crc_au8, /* Pointer to the CRC buffer */
        0x01A0u,     /* NV block Base number (defined by FEE/EA) */
        3u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DARH_DATA */
    ,{
        (NvM_RamAddressType)&darhNvData /* pointer to the RAM data buffer */,
        &darhNvDefaults /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_DARH_DATA_Crc_au8, /* Pointer to the CRC buffer */
        0x01C0u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DEM_STATUS */
    ,{
        (NvM_RamAddressType)&Dem_NvStatusData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_DEM_STATUS_Crc_au8, /* Pointer to the CRC buffer */
        0x01E0u,     /* NV block Base number (defined by FEE/EA) */
        104u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_MtrPos_MtrPosSnsr_EOLData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_MtrPos_MtrPosSnsr_EOLData /* pointer to the RAM data buffer */,
        DfltConfigData_MtrPosSnsr_EOLData,
        NULL_PTR, /* no Job End notification callback */
        Rte_NvmBlock_MtrPos_MtrPosSnsr_EOLData_Crc_au8, /* Pointer to the CRC buffer */
        0x0680u,     /* NV block Base number (defined by FEE/EA) */
        312u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_MtrCurr_ShCurrCal */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_MtrCurr_ShCurrCal /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0200u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_HwTrq_HwTrqScaleData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_HwTrq_HwTrqScaleData /* pointer to the RAM data buffer */,
        &T_InitHwTrq_HwTrqScaleData /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0220u,     /* NV block Base number (defined by FEE/EA) */
        5u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_Polarity_EOLCtrlPolarity */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_Polarity_k_SystemPolarity_Cnt_b16 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        Rte_NvmBlock_Polarity_EOLCtrlPolarity_Crc_au8, /* Pointer to the CRC buffer */
        0x0240u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_HwTrq_HwTrqTrimData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_HwTrq_HwTrqTrimData /* pointer to the RAM data buffer */,
        &T_InitHwTrq_HwTrqTrimData /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        Rte_NvmBlock_HwTrq_HwTrqTrimData_Crc_au8, /* Pointer to the CRC buffer */
        0x0260u,     /* NV block Base number (defined by FEE/EA) */
        13u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DIAGMGR_NTCSTRG */
    ,{
        (NvM_RamAddressType)&NTCStrgArray_Cnt_str /* pointer to the RAM data buffer */,
        Rte_Call_Nvm_RpNotifyInit__NVM_BLOCK_DIAGMGR_NTCSTRG_InitBlock,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0280u,     /* NV block Base number (defined by FEE/EA) */
        75u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_EPSDEFEATS */
    ,{
        (NvM_RamAddressType)&CDD_EOLSrlComSvcDft_Cnt_G_b32 /* pointer to the RAM data buffer */,
        &T_InitEPSDefeats_Cnt_u32 /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_EPSDEFEATS_Crc_au8, /* Pointer to the CRC buffer */
        0x02A0u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_ParamComp_EOLNomMtrParam */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_ParamComp_EOLNomMtrParam /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x02C0u,     /* NV block Base number (defined by FEE/EA) */
        12u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_STAMD_TYPEH */
    ,{
        (NvM_RamAddressType)&TypeHData_Cnt_u08 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x02E0u,     /* NV block Base number (defined by FEE/EA) */
        100u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_TrqCmdScl_TorqueCmdSF_Uls_f32 */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_TrqCmdScl_TorqueCmdSF_Uls_f32 /* pointer to the RAM data buffer */,
        DfltConfigData_TrqCmdScl_TorqueCmdSF_Uls_f32,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0300u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SVK_SYS_SUPP */
    ,{
        (NvM_RamAddressType)&VehCfg_SvkSysSupp /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x00C0u,     /* NV block Base number (defined by FEE/EA) */
        66u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SVK_PLANT */
    ,{
        (NvM_RamAddressType)&VehCfg_SvkPlant /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x00E0u,     /* NV block Base number (defined by FEE/EA) */
        66u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_LrnEOT_LearnedEOT */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_LrnEOT_LearnedEOT /* pointer to the RAM data buffer */,
        &T_InitLearnedEOT /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0320u,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_NXTRMEC */
    ,{
        (NvM_RamAddressType)&Nvm_NMEC_Cnt_u8 /* pointer to the RAM data buffer */,
        &T_InitNMEC_Cnt_u8 /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0340u,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_ECUSRLNUM */
    ,{
        (NvM_RamAddressType)&Nvm_EcuSrlNum_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0360u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_EPSSRLNUM */
    ,{
        (NvM_RamAddressType)&Nvm_EpsSrlNum_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0380u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_ECUHWPN */
    ,{
        (NvM_RamAddressType)&Nvm_EcuHwPn_Cnt_u8 /* pointer to the RAM data buffer */,
        Rte_Call_Nvm_RpNotifyInit__NVM_BLOCK_CMS_ECUHWPN_InitBlock,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x03A0u,     /* NV block Base number (defined by FEE/EA) */
        12u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_NXTRMANUFSCRATCHPAD */
    ,{
        (NvM_RamAddressType)&Nvm_NxtrManfScrpd_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x03C0u,     /* NV block Base number (defined by FEE/EA) */
        64u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_IGNCNTR */
    ,{
        (NvM_RamAddressType)&Nvm_IgnCntr_Cnt_u16 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x03E0u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_HwTrq_EOLTrqStepData_HwNm_f32 */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_HwTrq_EOLTrqStepData /* pointer to the RAM data buffer */,
        DfltConfigData_HwTrq_EOLTrqStepData,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0400u,     /* NV block Base number (defined by FEE/EA) */
        40u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DEM_PRIMARY */
    ,{
        (NvM_RamAddressType)&Dem_NvGateEntryPrimaryData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        Dem_NvMGateEntryPrimaryBlockCallback, /* Job End notification callback (application defined) */
        NVM_BLOCK_DEM_PRIMARY_Crc_au8, /* Pointer to the CRC buffer */
        0x0420u,     /* NV block Base number (defined by FEE/EA) */
        47u,    /* Length of the block in bytes */
        30u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_DATASET,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DEM_SECONDARY */
    ,{
        (NvM_RamAddressType)&Dem_NvGateEntrySecondaryData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        Dem_NvMGateEntrySecondaryBlockCallback, /* Job End notification callback (application defined) */
        NVM_BLOCK_DEM_SECONDARY_Crc_au8, /* Pointer to the CRC buffer */
        0x0440u,     /* NV block Base number (defined by FEE/EA) */
        47u,    /* Length of the block in bytes */
        24u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_DATASET,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_LnRkCtr_RackCntrData */
    ,{
        (NvM_RamAddressType)&Rte_LnRkCr_LearnedRackCntr /* pointer to the RAM data buffer */,
        &T_InitLnRkCtr_RackCntrData /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0460u,     /* NV block Base number (defined by FEE/EA) */
        14u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_AbsHwPos_EOLHwOffsetSnsrCal */
    ,{
        (NvM_RamAddressType)&Rte_AbsHwPos_EOLHwOffsetSnsrCal /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0480u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_SWT_SW */
    ,{
        (NvM_RamAddressType)&Swt_SWData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x04A0u,     /* NV block Base number (defined by FEE/EA) */
        376u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_SWT_SWSIG */
    ,{
        (NvM_RamAddressType)&Swt_SWSigData /* pointer to the RAM data buffer */,
        &Swt_SWSigData /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x04C0u,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_VehCfg_PrevVldTuningSel */
    ,{
        (NvM_RamAddressType)&Rte_VehCfg_PrevVldTuningSel /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x04E0u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DIAGMGR_BLACKBOX */
    ,{
        (NvM_RamAddressType)&NTCBlackBoxData_Cnt_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0500u,     /* NV block Base number (defined by FEE/EA) */
        192u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_STAMD_CLOSECHECK */
    ,{
        (NvM_RamAddressType)&NvMP_CloseCheck_Cnt_u32 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0520u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_AbsHwPos_Trim */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_AbsHwPos_Trim /* pointer to the RAM data buffer */,
        &T_InitAbsHwPos_Trim /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        Rte_NvmBlock_AbsHwPos_Trim_Crc_au8, /* Pointer to the CRC buffer */
        0x0540u,     /* NV block Base number (defined by FEE/EA) */
        14u,    /* Length of the block in bytes */
        2u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_REDUNDANT,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_TurnsCounter_EOLTurnsCntrCals */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_TurnsCounter_EOLTurnsCntrCals /* pointer to the RAM data buffer */,
        Rte_Call_Nvm_RpNotifyInit__Rte_NvmBlock_TurnsCounter_EOLTurnsCntrCals_InitBlock,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0560u,     /* NV block Base number (defined by FEE/EA) */
        6u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_HWDESCDATA */
    ,{
        (NvM_RamAddressType)&HwDescData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0120u,     /* NV block Base number (defined by FEE/EA) */
        59u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal */
    ,{
        (NvM_RamAddressType)&Rte_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0580u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_TCFLSHPRG_TCFLSHDATA */
    ,{
        (NvM_RamAddressType)&TcFlshDataNvm_Uls_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x05A0u,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_CALID */
    ,{
        (NvM_RamAddressType)&Edch_CalId_val /* pointer to the RAM data buffer */,
        &Edch_CalIdDefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x05C0u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_CVN */
    ,{
        (NvM_RamAddressType)&Edch_Cvn_val /* pointer to the RAM data buffer */,
        &Edch_CvnDefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x05E0u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_OPCYCLESTATE */
    ,{
        (NvM_RamAddressType)&Edch_OperationCycleState /* pointer to the RAM data buffer */,
        &Edch_OperationCycleStateDefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0600u,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_SUBCVN0 */
    ,{
        (NvM_RamAddressType)&Edch_SubCvn_0_val /* pointer to the RAM data buffer */,
        &Edch_SubCvn_0_DefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0620u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_SUBCVN1 */
    ,{
        (NvM_RamAddressType)&Edch_SubCvn_1_val /* pointer to the RAM data buffer */,
        &Edch_SubCvn_1_DefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0640u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_EDCH_SUBCVN2 */
    ,{
        (NvM_RamAddressType)&Edch_SubCvn_2_val /* pointer to the RAM data buffer */,
        &Edch_SubCvn_2_DefaultVal /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0660u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_FEE_INITIALIZED */
    ,{
        (NvM_RamAddressType)&Nxtr_FeeInitialized_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0140u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SVK_HISTORY */
    ,{
        (NvM_RamAddressType)&SvkHistoryMemory /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0100u,     /* NV block Base number (defined by FEE/EA) */
        133u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_MTRSUPLR_SERVICE */
    ,{
        (NvM_RamAddressType)&Nvm_MtrSuplrByte_Cnt_u8 /* pointer to the RAM data buffer */,
        &T_MtrSuplrService_Data /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x06A0u,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_ELEC_HW_INDEX */
    ,{
        (NvM_RamAddressType)&Nvm_ElecHwIndex_Cnt_u16 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x06C0u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_AvgFricLrn_AvgFricLrnData */
    ,{
        (NvM_RamAddressType)&Rte_AvgFricLrn_AvgFricLrnData /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x06E0u,     /* NV block Base number (defined by FEE/EA) */
        203u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CODING_DATA */
    ,{
        (NvM_RamAddressType)&Coding_NvData /* pointer to the RAM data buffer */,
        &Coding_NvDataDefaults /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_CODING_DATA_Crc_au8, /* Pointer to the CRC buffer */
        0x0700u,     /* NV block Base number (defined by FEE/EA) */
        159u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_ON |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_OFF |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_ActivePull_PullCmpLTComp_HwNm_f32 */
    ,{
        (NvM_RamAddressType)&Rte_ActivePull_PullCmpLTComp_HwNm_f32 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0720u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
/*</NVM_DESCRIPTOR_TABLE_CONFIG>*/
    };

#if(NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON)
   /* The table containing each RAM block's effective (i.e. CRC size subtracted, if necessary) length.
      Since, for very small RAM block's this length may become negative, it is signed.
      A value smaller than -128 indicates: Don't check this block (no RAM block given).
    */
   static CONST(sint32, NVM_CONFIG_CONST) NvM_RamBlockLengthTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        -128
/*<NVM_CONFIG_RAMBLOCK_SIZE/>*/

    };
#endif

#if(NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON)
   /* The table containing each ROM block's length.
      Though these lengths are alway positive, the type is signed (because of RAM block lengths).
      A value equal to or smaller than -128 indicates: Don't check this block (no RAM block given).
    */
    static CONST(sint32, NVM_CONFIG_CONST) NvM_RomBlockLengthTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        -128,
        -128 /* ConfigBlock */
        ,-128 /* NVM_BLOCK_BOOT_PROG_STATUS */
        ,sizeof(Vsm_OmcNvData_Default) /* NVM_BLOCK_VSMOMC_DATA */
        ,-128 /* NVM_BLOCK_BOOT_PROG_COUNTER */
        ,-128 /* NVM_BLOCK_BOOT_PROG_DATA */
        ,-128 /* Deprecated_NVM_BLOCK_CODING_DATA */
        ,sizeof(Coding_NvStatusDefaults) /* NVM_BLOCK_CODING_STATUS */
        ,sizeof(Cdc_NvDataDefault) /* NVM_BLOCK_CDC_DATA */
        ,sizeof(darhNvDefaults) /* NVM_BLOCK_DARH_DATA */
        ,-128 /* NVM_BLOCK_DEM_STATUS */
        ,-128 /* Rte_NvmBlock_MtrPos_MtrPosSnsr_EOLData */
        ,-128 /* Rte_NvmBlock_MtrCurr_ShCurrCal */
        ,sizeof(T_InitHwTrq_HwTrqScaleData) /* Rte_NvmBlock_HwTrq_HwTrqScaleData */
        ,-128 /* Rte_NvmBlock_Polarity_EOLCtrlPolarity */
        ,sizeof(T_InitHwTrq_HwTrqTrimData) /* Rte_NvmBlock_HwTrq_HwTrqTrimData */
        ,-128 /* NVM_BLOCK_DIAGMGR_NTCSTRG */
        ,sizeof(T_InitEPSDefeats_Cnt_u32) /* NVM_BLOCK_EPSDEFEATS */
        ,-128 /* Rte_NvmBlock_ParamComp_EOLNomMtrParam */
        ,-128 /* NVM_BLOCK_STAMD_TYPEH */
        ,-128 /* Rte_NvmBlock_TrqCmdScl_TorqueCmdSF_Uls_f32 */
        ,-128 /* NVM_BLOCK_SVK_SYS_SUPP */
        ,-128 /* NVM_BLOCK_SVK_PLANT */
        ,sizeof(T_InitLearnedEOT) /* Rte_NvmBlock_LrnEOT_LearnedEOT */
        ,sizeof(T_InitNMEC_Cnt_u8) /* NVM_BLOCK_CMS_NXTRMEC */
        ,-128 /* NVM_BLOCK_CMS_ECUSRLNUM */
        ,-128 /* NVM_BLOCK_CMS_EPSSRLNUM */
        ,-128 /* NVM_BLOCK_CMS_ECUHWPN */
        ,-128 /* NVM_BLOCK_CMS_NXTRMANUFSCRATCHPAD */
        ,-128 /* NVM_BLOCK_CMS_IGNCNTR */
        ,-128 /* Rte_NvmBlock_HwTrq_EOLTrqStepData_HwNm_f32 */
        ,-128 /* NVM_BLOCK_DEM_PRIMARY */
        ,-128 /* NVM_BLOCK_DEM_SECONDARY */
        ,sizeof(T_InitLnRkCtr_RackCntrData) /* Rte_NvmBlock_LnRkCtr_RackCntrData */
        ,-128 /* Rte_NvmBlock_AbsHwPos_EOLHwOffsetSnsrCal */
        ,-128 /* NVM_SWT_SW */
        ,sizeof(Swt_SWSigData) /* NVM_SWT_SWSIG */
        ,-128 /* Rte_NvmBlock_VehCfg_PrevVldTuningSel */
        ,-128 /* NVM_BLOCK_DIAGMGR_BLACKBOX */
        ,-128 /* NVM_BLOCK_STAMD_CLOSECHECK */
        ,sizeof(T_InitAbsHwPos_Trim) /* Rte_NvmBlock_AbsHwPos_Trim */
        ,-128 /* Rte_NvmBlock_TurnsCounter_EOLTurnsCntrCals */
        ,-128 /* NVM_BLOCK_HWDESCDATA */
        ,-128 /* Rte_NvmBlock_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal */
        ,-128 /* NVM_BLOCK_TCFLSHPRG_TCFLSHDATA */
        ,sizeof(Edch_CalIdDefaultVal) /* NVM_EDCH_CALID */
        ,sizeof(Edch_CvnDefaultVal) /* NVM_EDCH_CVN */
        ,sizeof(Edch_OperationCycleStateDefaultVal) /* NVM_EDCH_OPCYCLESTATE */
        ,sizeof(Edch_SubCvn_0_DefaultVal) /* NVM_EDCH_SUBCVN0 */
        ,sizeof(Edch_SubCvn_1_DefaultVal) /* NVM_EDCH_SUBCVN1 */
        ,sizeof(Edch_SubCvn_2_DefaultVal) /* NVM_EDCH_SUBCVN2 */
        ,-128 /* NVM_FEE_INITIALIZED */
        ,-128 /* NVM_BLOCK_SVK_HISTORY */
        ,sizeof(T_MtrSuplrService_Data) /* NVM_BLOCK_MTRSUPLR_SERVICE */
        ,-128 /* NVM_BLOCK_ELEC_HW_INDEX */
        ,-128 /* Rte_NvmBlock_AvgFricLrn_AvgFricLrnData */
        ,sizeof(Coding_NvDataDefaults) /* NVM_BLOCK_CODING_DATA */
        ,-128 /* Rte_NvmBlock_ActivePull_PullCmpLTComp_HwNm_f32 */

    };
#endif

#define NVM_STOP_SEC_CONST_DESCRIPTOR_TABLE
#include "MemMap.h"

#define NVM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"
    #if(NVM_API_CONFIG_CLASS != NVM_API_CONFIG_CLASS_1)

            /* Job Queue used for normal and high prio jobs */
            VAR(NvM_QueueEntryType, NVM_PRIVATE_DATA)
                NvM_JobQueue_at[NVM_SIZE_STANDARD_JOB_QUEUE + NVM_SIZE_IMMEDIATE_JOB_QUEUE];

    #endif

      /* Crc job queue. It's just a bit string */
    VAR(NvM_CrcQueueEntryType, NVM_CONFIG_DATA) NvM_CrcQueue_at[NVM_SIZE_CRC_JOB_QUEUE];

#define NVM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

#define NVM_START_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include "MemMap.h"

    /* array of RAM Block Management areas, defined to be usable in block descriptor table */
    VAR(NvM_RamMngmtAreaType, NVM_CONFIG_DATA) NvM_BlockMngmtArea_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS];

	/* management area for DCM blocks */
    VAR(NvM_RamMngmtAreaType, NVM_CONFIG_DATA) NvM_DcmBlockMngmt_t;

#define NVM_STOP_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include "MemMap.h"


#define NVM_START_SEC_CODE
#include "MemMap.h"

/*!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!   Function name: NvM_EnterCriticalSection()
!
!-----------------------------------------------------------------------------
!   Function Description: Lock resources
!-----------------------------------------------------------------------------
!   Module Global:  none
!   Parameter:      none
!   Returnvalue:    none
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
FUNC(void, NVM_PRIVATE_CODE) NvM_EnterCriticalSection(void)
{
    /* do what ever was defined to do for locking the resourcees */
    /*<NVM_LOCK_RESOURCE/>*/ SchM_Enter_NvM(NVM_EXCLUSIVE_AREA_0);
}


/*!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!   Function name: NvM_ExitCriticalSection()
!
!-----------------------------------------------------------------------------
!   Function Description: Unlock resources
!-----------------------------------------------------------------------------
!   Module Global:  none
!   Parameter:      none
!   Returnvalue:    none
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
FUNC(void, NVM_PRIVATE_CODE) NvM_ExitCriticalSection(void)
{
    /* do what ever was defined to do for unlocking the resourcees */
    /*<NVM_UNLOCK_RESOURCE/>*/ SchM_Exit_NvM(NVM_EXCLUSIVE_AREA_0);
}

#if(NVM_USE_CRC16 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc16_Calculate(NvM_ConstRamAddressType data_pt, uint16 length, NvM_CrcValuePtrType currCrc)
    {
        /* Pointer cast is necessary for efficiency reasons. 
         * We cast to a "smaller" type with less alignment requirements; it is harmless */
        typedef P2VAR(uint16, AUTOMATIC, NVM_CRC_BUFFER_PTR_CLASS) NvM_Crc16PtrType;
        *(NvM_Crc16PtrType)currCrc = Crc_CalculateCRC16(data_pt, length, *(NvM_Crc16PtrType)currCrc);
    }

    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc16_Compare(NvM_CrcBufferConstPtrType crc1, NvM_CrcValueRefType crc2)
    {
        return ((crc1[0] == crc2[0]) && (crc1[1] == crc2[1]));
    }

    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc16_CopyToBuffer (NvM_CrcBufferPtrType dest, NvM_CrcValueRefType src)
    {
        dest[0] = src[0];
        dest[1] = src[1];
    }
#endif

#if(NVM_USE_CRC32 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc32_Calculate(NvM_ConstRamAddressType data_pt, uint16 length, NvM_CrcValuePtrType currCrc)
    {
        *currCrc = Crc_CalculateCRC32(data_pt, length, (*currCrc) ^ NVM_CRC32_XOR_VALUE);
    }

    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc32_Compare(NvM_CrcBufferConstPtrType crc1, NvM_CrcValueRefType crc2)
    {
        return ((crc1[0] == crc2[0]) && (crc1[1] == crc2[1]) && (crc1[2] == crc2[2]) && (crc1[3] == crc2[3]));
    }

    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc32_CopyToBuffer (NvM_CrcBufferPtrType dest, NvM_CrcValueRefType src)
    {
        dest[0] = src[0];
        dest[1] = src[1];
        dest[2] = src[2];
        dest[3] = src[3];
    }
#endif


/*<NVM_CFG_BLOCK_INT_CBK_DEF/>*/



/*<NVM_CHK_BLOCKS_COMPARE_DEF/>*/

#if(NVM_DEV_ERROR_DETECT == STD_ON)
#if((NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON) || (NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON))
    static FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckBlockLengthsGeneric(P2CONST(sint32, AUTOMATIC, NVM_CONFIG_CONST));

    static FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckBlockLengthsGeneric(
                                                    P2CONST(sint32, AUTOMATIC, NVM_CONFIG_CONST) refLengths)
    {
        uint8_least retVal = FALSE; /* initialize retVal to FALSE (not failed) */

        uint16_least blockId = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS;

        do
        {
            --blockId;
            /* don't check block's length, if the reference length is 0 */
            if(refLengths[blockId] > -128)
            {
                const uint16_least NvLength = NvM_BlockDescriptorTable_at[blockId].NvBlockLength_u16;

                if(!NvM_LengthCheck(NvLength, refLengths[blockId]))
                {
                    /* don't leave the loop, this shall ease debugging */
                    retVal = TRUE; /* check FAILED */
                }
            }
        } while(blockId > 0);

        return retVal;
    }
#endif


    FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckRamBlockLengths(void)
    {
#if(NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON)
        return NvM_CfgCheckBlockLengthsGeneric(NvM_RamBlockLengthTable_at);
#else
        return FALSE; /* check not failed */
#endif
    }

    FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckRomBlockLengths(void)
    {
#if(NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON)
        return NvM_CfgCheckBlockLengthsGeneric(NvM_RomBlockLengthTable_at);
#else
        return FALSE; /* check not failed */
#endif
    }
#endif

#define NVM_STOP_SEC_CODE
#include "MemMap.h"


/* ---- End of File ------------------------------------------------------- */
