#ifndef DEM_INTERNAL_DEPEND_H
/** \brief preprocessor exclusion definition */
#define DEM_INTERNAL_DEPEND_H

/** \file
 ** \brief AUTOSAR Dem Diagnostic Event Manager
 **
 ** This file contains all configuration dependent internal API declarations
 ** of the AUTOSAR module Dem.
 **
 ** \project AUTOSAR Standard Core
 ** \author Georg Drenkhahn
 ** \author Marko Schneider
 ** \author 3SOFT GmbH, 91058 Erlangen, Germany
 **
 ** $Id: Dem_Internal_Depend.h 2547 2011-08-22 13:24:09Z olho2924 $
 ** Release: $3SOFT_DELIVERY_VERSION_INFORMATION$
 **
 ** \controller independent
 ** \compiler   independent
 ** \hardware   independent
 **
 ** Copyright 2005,2006 by 3SOFT GmbH
 ** All rights exclusively reserved for 3SOFT GmbH,
 ** unless expressly agreed to otherwise */

/** \addtogroup Dem Diagnostic Event Manager
 ** @{ */

/*==================[inclusions]============================================*/

#include <Std_Types.h>                            /* AUTOSAR standard types */

#include <NvM.h>                              /* for usage of NvRam Manager */

#include <Dem_Api_Depend_Specific.h>  /* Module public API, config. depend. */

#include <Dem_Internal_Static_Specific.h>  /* API and internal static decl. */
#include <Dem_Internal_Cfg_Specific.h>   /* Internal generated declarations */

#if (DEM_INCLUDE_RTE == STD_ON)
#include <Rte_DEM.h>                                /* API generated by RTE */
#endif


/*==================[macros]================================================*/

/* Dependent value: mask (depends on configurational value width) */

#if (defined DEM_DTC_WIDTH)
#if (defined DEM_DTC_MASK)
#error DEM_DTC_MASK already defined
#endif
#define DEM_DTC_MASK                 ((1UL << DEM_DTC_WIDTH) - 1UL)
#endif

#if (defined DEM_DTCKIND_WIDTH)
#if (defined DEM_DTCKIND_MASK)
#error DEM_DTCKIND_MASK already defined
#endif
#define DEM_DTCKIND_MASK             ((1UL << DEM_DTCKIND_WIDTH) - 1UL)
#endif

#if (defined DEM_DTCORIGIN_WIDTH)
#if (defined DEM_DTCORIGIN_MASK)
#error DEM_DTCORIGIN_MASK already defined
#endif
#define DEM_DTCORIGIN_MASK           ((1UL << DEM_DTCORIGIN_WIDTH) - 1UL)
#endif

#if (defined DEM_DTCGROUP_WIDTH)
#if (defined DEM_DTCGROUP_MASK)
#error DEM_DTCGROUP_MASK already defined
#endif
#define DEM_DTCGROUP_MASK            ((1UL << DEM_DTCGROUP_WIDTH) - 1UL)
#endif

#if (defined DEM_DTCSEVERITY_WIDTH)
#if (defined DEM_DTCSEVERITY_MASK)
#error DEM_DTCSEVERITY_MASK already defined
#endif
#define DEM_DTCSEVERITY_MASK         ((1UL << DEM_DTCSEVERITY_WIDTH) - 1UL)
#endif

#if (defined DEM_PRESTORAGE_WIDTH)
#if (defined DEM_PRESTORAGE_MASK)
#error DEM_PRESTORAGE_MASK already defined
#endif
#define DEM_PRESTORAGE_MASK    ((1UL << DEM_PRESTORAGE_WIDTH) - 1UL)
#endif

#if (defined DEM_FFCLASSIDX_WIDTH)
#if (defined DEM_FFCLASSIDX_MASK)
#error DEM_FFCLASSIDX_MASK already defined
#endif
#define DEM_FFCLASSIDX_MASK          ((1UL << DEM_FFCLASSIDX_WIDTH) - 1UL)
#endif

#if (defined DEM_MAXNUMFF_WIDTH)
#if (defined DEM_MAXNUMFF_MASK)
#error DEM_MAXNUMFF_MASK already defined
#endif
#define DEM_MAXNUMFF_MASK            ((1UL << DEM_MAXNUMFF_WIDTH) - 1UL)
#endif

#if (defined DEM_EDCLASSIDX_WIDTH)
#if (defined DEM_EDCLASSIDX_MASK)
#error DEM_EDCLASSIDX_MASK already defined
#endif
#define DEM_EDCLASSIDX_MASK          ((1UL << DEM_EDCLASSIDX_WIDTH) - 1UL)
#endif

#if (defined DEM_OPCYCLEIDX_WIDTH)
#if (defined DEM_OPCYCLEIDX_MASK)
#error DEM_OPCYCLEIDX_MASK already defined
#endif
#define DEM_OPCYCLEIDX_MASK          ((1UL << DEM_OPCYCLEIDX_WIDTH) - 1UL)
#endif

#if (defined DEM_HEALINGCYCLES_WIDTH)
#if (defined DEM_HEALINGCYCLES_MASK)
#error DEM_HEALINGCYCLES_MASK already defined
#endif
#define DEM_HEALINGCYCLES_MASK       ((1UL << DEM_HEALINGCYCLES_WIDTH) - 1UL)
#endif

#if (defined DEM_ENCONDID_WIDTH)
#if (defined DEM_ENCONDID_MASK)
#error DEM_ENCONDID_MASK already defined
#endif
#define DEM_ENCONDID_MASK            ((1UL << DEM_ENCONDID_WIDTH) - 1UL)
#endif

#if (defined DEM_VIEWID_WIDTH)
#if (defined DEM_VIEWID_MASK)
#error DEM_VIEWID_MASK already defined
#endif
#define DEM_VIEWID_MASK              ((1UL << DEM_VIEWID_WIDTH) - 1UL)
#endif

#if (defined DEM_INDICATORUSED_WIDTH)
#if (defined DEM_INDICATORUSED_MASK)
#error DEM_INDICATORUSED_MASK already defined
#endif
#define DEM_INDICATORUSED_MASK       ((1UL << DEM_INDICATORUSED_WIDTH) - 1UL)
#endif

#if (defined DEM_PRIORITY_WIDTH)
#if (defined DEM_PRIORITY_MASK)
#error DEM_PRIORITY_MASK already defined
#endif
#define DEM_PRIORITY_MASK            ((1UL << DEM_PRIORITY_WIDTH) - 1UL)
#endif

#if (defined DEM_DEBOUNCEALGO_WIDTH)
#if (defined DEM_DEBOUNCEALGO_MASK)
#error DEM_DEBOUNCEALGO_MASK already defined
#endif
#define DEM_DEBOUNCEALGO_MASK        ((1UL << DEM_DEBOUNCEALGO_WIDTH) - 1UL)
#endif

#if (defined DEM_DEBOUNCEIDX_WIDTH)
#if (defined DEM_DEBOUNCEIDX_MASK)
#error DEM_DEBOUNCEIDX_MASK already defined
#endif
#define DEM_DEBOUNCEIDX_MASK         ((1UL << DEM_DEBOUNCEIDX_WIDTH) - 1UL)
#endif

/*==================[type definitions]======================================*/

/** \brief Static event/DTC description type
 **
 ** The 'bit packing scheme' is used. Access to the values is possible with
 ** the getter functions like Dem_GbiDTC().*/
typedef struct
{
   #if (defined DEM_EVENTDESCTYPE_VAR0)
   DEM_EVENTDESCTYPE_VAR0 EvConfig1;
   #endif

   #if (defined DEM_EVENTDESCTYPE_VAR1)
   DEM_EVENTDESCTYPE_VAR1 EvConfig2;
   #endif

   #if (defined DEM_EVENTDESCTYPE_VAR2)
   DEM_EVENTDESCTYPE_VAR2 EvConfig3;
   #endif

} Dem_EventDescType;

/*------------------[definitions for warning indicators]--------------------*/

#if (DEM_USE_INDICATOR == STD_ON)

/** \brief Type used for the warning indicator configuration description */
typedef struct
{
   /** Number of events assinged to this indicator */
   Dem_EventIdType Number;
   /** Index in Dem_IndicatorLink[], where the links for this indicators
    ** begin - may be invalid if Number is 0 */
   uint32 StartIdx;
} Dem_IndicatorDescType;

/** \brief Type used for the warning indicator-link configuration list */
typedef struct
{
   /** Event Id to which this indicator is linked to */
   Dem_EventIdType EventId;
   /** Indicator behaviour (which does not use ::DEM_INDICATOR_OFF) */
   Dem_IndicatorStatusType Behaviour;
} Dem_IndicatorLinkType;

#endif

/*------------------[definitions for debouncing]----------------------------*/

/** \brief Debounce algorithm type */
typedef enum
{
   DEM_DEBOUNCE_MONITOR,
                   /**< value/index signaling "monitor internal" debouncing */
#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
   DEM_DEBOUNCE_COUNTERBASED,
                        /**< value/index signaling counter based debouncing */
#endif
#if (DEM_NUM_DEBOUNCE_TIME > 0U)
   DEM_DEBOUNCE_TIMEBASED,
                           /**< value/index signaling time based debouncing */
#endif
#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
   DEM_DEBOUNCE_FREQUENCYBASED,
                      /**< value/index signaling frequency based debouncing */
#endif
   DEM_MAXNUM_DEBOUNCECLASSES
           /**< Maximal number of different configurable debouncing classes */
} Dem_DebounceType;

#if (DEM_USE_DEBOUNCE == STD_ON)

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief Configuration description of counter based debouncing algorithm */
typedef struct
{
   uint8   CountOutStepSize;  /**< step size for decrementation (PREPASSED) */
   uint8   CountInStepSize;   /**< step size for incrementation (PREFAILED) */
   boolean JumpUp;                                    /**< Jump-Up enabled? */
   boolean JumpDown;                                /**< Jump-down enabled? */
} Dem_DebounceCounterCfgType;

/** \brief Status information for counter based debouncing algorithm */
typedef struct
{
   Dem_FaultDetectionCounterType FDC;    /**< fault detection counter value */
} Dem_DebounceCounterStatusType;
#endif /* DEM_NUM_DEBOUNCE_COUNTER */

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief Configuration description of time based debouncing algorithm */
typedef struct
{
   uint32           TimeFailedThreshold;
                         /**< "event failed" timeout in main function ticks */
   uint32           TimePassedThreshold;
                         /**< "event passed" timeout in main function ticks */
   Dem_EventIdType  EventId;          /**< event id for backwards reference */
} Dem_DebounceTimeCfgType;

/** \brief Status information for time based debouncing algorithm */
typedef struct
{
   uint32                        TimerValue;
     /**< remaining timer value in main function ticks, 0=timer not running */
   Dem_EventStatusType           Direction;
                                 /**< direction of timer (PASSED or FAILED) */
   Dem_FaultDetectionCounterType SavedFDC;
                               /**< FDC to report when timer is not running */
} Dem_DebounceTimeStatusType;
#endif /* DEM_NUM_DEBOUNCE_TIME */

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief Configuration description of frequency based debouncing algorithm */
typedef struct
{
   uint32           TimeWindowDuration;
                        /**< duration of time window in main function ticks */
   uint16           ThresholdBeforeEvFailed;
                        /**< threshold for "failed" counter decresed by one */
   uint16           ThresholdBeforeEvPassed;
                        /**< threshold for "passed" counter decresed by one */
   Dem_EventIdType  EventId;          /**< event id for backwards reference */
} Dem_DebounceFrequencyCfgType;

/** \brief Status information for frequency based debouncing algorithm */
typedef struct
{
   uint32                        TimerValue;
     /**< remaining timer value in main function ticks, 0=timer not running */
   uint16                        PassedCounter;
                                             /**< value of "passed" counter */
   uint16                        FailedCounter;
                                             /**< value of "failed" counter */
   Dem_FaultDetectionCounterType SavedFDC;
                               /**< FDC to report when timer is not running */
} Dem_DebounceFrequencyStatusType;
#endif /* DEM_NUM_DEBOUNCE_FREQUENCY */

/** \brief Function pointer type for generic "Reset Counters" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceResetFctPtrType) (
   Dem_EventIdType EventId);

/** \brief Function pointer type for generic "DebounceEvent" function */
typedef P2FUNC(void, DEM_APPL_CODE, Dem_DebounceEventFctPtrType) (
   Dem_EventIdType                                      EventId,
   P2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Function pointer type for generic "GetFDC" function */
typedef P2FUNC(Std_ReturnType, DEM_APPL_CODE, Dem_DebounceGetFDCFctPtrType) (
   Dem_EventIdType                                                EventId,
   P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);

/** \brief Type for debouncing function pointer table entries */
typedef struct
{
   Dem_DebounceResetFctPtrType  ResetFct;
               /**< reset status (Dem_ClearDTC, Dem_SetOperationCycleState) */
   Dem_DebounceEventFctPtrType  DebounceEventFct;
            /**< debounce event (Dem_ReportErrorStatus, Dem_SetEventStatus) */
   Dem_DebounceGetFDCFctPtrType GetFDCFct;
                                  /**< return fault detection counter value */
} Dem_DebounceFctPtrTableType;

#endif /* DEM_USE_DEBOUNCE */

/*------------------[definitions for enable condition]----------------------*/

#if (DEM_USE_ENABLE_CONDITION == STD_ON)
/** \brief This type is used as index type for the enable conditions
 **
 ** Its size (uint8) is given by API Dem_SetEnableCondition(). */
typedef uint8 Dem_EnableConditionIdType;
#endif

/*==================[external function declarations]========================*/

#define DEM_START_SEC_CODE
#include "MemMap.h"

/*------------------[Getter-Functions for the Event Descriptions]-----------*/

/** \brief Get DTC-value from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DTC_VALUE)
   #define Dem_GbiDTC(x) DEM_GLOBAL_DTC_VALUE
#else
extern FUNC(uint32, DEM_CODE) Dem_GbiDTC(const Dem_EventIdType EventId);
#endif

/** \brief Get DTC-kind from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DTCKIND_VALUE)
   #define Dem_GbiDTCKind(x) DEM_GLOBAL_DTCKIND_VALUE
#else
extern FUNC(Dem_DTCKindType, DEM_CODE) Dem_GbiDTCKind(
   const Dem_EventIdType EventId);
#endif

/** \brief Get DTC-origin from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DTCORIGIN_VALUE)
   #define Dem_GbiDTCOrigin(x) DEM_GLOBAL_DTCORIGIN_VALUE
#else
extern FUNC(Dem_DTCOriginType, DEM_CODE) Dem_GbiDTCOrigin(
   const Dem_EventIdType EventId);
#endif

/** \brief Get DTC-group-index from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DTCGROUP_VALUE)
   #define Dem_GbiDTCGroupIdx(x) DEM_GLOBAL_DTCGROUP_VALUE
#else
extern FUNC(uint8, DEM_CODE) Dem_GbiDTCGroupIdx(
   const Dem_EventIdType EventId);
#endif

/** \brief Get DTC-severity from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DTCSEVERITY_VALUE)
   #define Dem_GbiDTCSeverity(x) DEM_GLOBAL_DTCSEVERITY_VALUE
#else
extern FUNC(Dem_DTCSeverityType, DEM_CODE) Dem_GbiDTCSeverity(
   const Dem_EventIdType EventId);
#endif

/** \brief Get FF-class-index from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_FFCLASSIDX_VALUE)
   #define Dem_GbiFFClassIdx(x) DEM_GLOBAL_FFCLASSIDX_VALUE
#else
extern FUNC(Dem_FFClassIdxType, DEM_CODE) Dem_GbiFFClassIdx(
   const Dem_EventIdType EventId);
#endif

/** \brief Get maximal-FF-count from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_MAXNUMFF_VALUE)
   #define Dem_GbiMaxNumFF(x) DEM_GLOBAL_MAXNUMFF_VALUE
#else
extern FUNC(Dem_FFIdxType, DEM_CODE) Dem_GbiMaxNumFF(
   const Dem_EventIdType EventId);
#endif

/** \brief Get ED-class-index from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_EDCLASSIDX_VALUE)
   #define Dem_GbiEDClassIdx(x) DEM_GLOBAL_EDCLASSIDX_VALUE
#else
extern FUNC(Dem_EDClassIdxType, DEM_CODE) Dem_GbiEDClassIdx(
   const Dem_EventIdType EventId);
#endif

/** \brief Get operation-cycle-index from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_OPCYCLEIDX_VALUE)
   #define Dem_GbiOpCycleIdx(x) DEM_GLOBAL_OPCYCLEIDX_VALUE
#else
extern FUNC(Dem_OperationCycleIdType, DEM_CODE) Dem_GbiOpCycleIdx(
   const Dem_EventIdType EventId);
#endif

/** \brief Get healing-cycles from ::Dem_EventDesc by using index */
#if (DEM_USE_HEALING == STD_ON)
/* if healing is for all events on and a global value exists, then
   easily return this value                                       */
#if ( (DEM_GLOBAL_HEALING_ALL_EVENTS == STD_ON) && (defined DEM_GLOBAL_HEALINGCYCLES_VALUE) )
   #define Dem_GbiHealingCycles(x) DEM_GLOBAL_HEALINGCYCLES_VALUE
#else
extern FUNC(Dem_HealingCyclesType, DEM_CODE) Dem_GbiHealingCycles(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_USE_ENABLE_CONDITION == STD_ON)
/** \brief Get enable-condition-Id from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_ENCONDID_VALUE)
   #define Dem_GbiEnCondId(x) DEM_GLOBAL_ENCONDID_VALUE
#else
extern FUNC(Dem_EnableConditionIdType, DEM_CODE) Dem_GbiEnCondId(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_USE_VIEWID == STD_ON)
/** \brief Get view-Id from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_VIEWID_VALUE)
   #define Dem_GbiViewId(x) DEM_GLOBAL_VIEWID_VALUE
#else
extern FUNC(Dem_ViewIdType, DEM_CODE) Dem_GbiViewId(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_USE_INDICATOR == STD_ON)
/** \brief Get indicator-used-flag from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_INDICATORUSED_VALUE)
   #define Dem_GbiIndicatorUsed(x) DEM_GLOBAL_INDICATORUSED_VALUE
#else
extern FUNC(boolean, DEM_CODE) Dem_GbiIndicatorUsed(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_USE_PRIORITY == STD_ON)
/** \brief Get priority from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_PRIORITY_VALUE)
   #define Dem_GbiPriority(x) DEM_GLOBAL_PRIORITY_VALUE
#else
extern FUNC(Dem_PriorityType, DEM_CODE) Dem_GbiPriority(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Get enable-prestorage-flag from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_PRESTORAGE_VALUE)
   #define Dem_GbiEnablePrestorage(x) DEM_GLOBAL_PRESTORAGE_VALUE
#else
extern FUNC(boolean, DEM_CODE) Dem_GbiEnablePrestorage(
   const Dem_EventIdType EventId);
#endif

/** \brief Get index of prestorage from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_PRESTORAGE_VALUE)
   #define Dem_GbiPrestorageIndex(x) DEM_GLOBAL_PRESTORAGE_VALUE
#else
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GbiPrestorageIndex(
   const Dem_EventIdType EventId);
#endif
#endif

#if (DEM_USE_DEBOUNCE == STD_ON)
/** \brief Get debounce algorithm from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DEBOUNCEALGO_VALUE)
   #define Dem_GbiDebounceAlgo(x) DEM_GLOBAL_DEBOUNCEALGO_VALUE
#else
extern FUNC(Dem_DebounceType, DEM_CODE) Dem_GbiDebounceAlgo(
   const Dem_EventIdType EventId);
#endif

/** \brief Get debounce index from ::Dem_EventDesc by using index */
#if (defined DEM_GLOBAL_DEBOUNCEIDX_VALUE)
   #define Dem_GbiDebounceIdx(x) DEM_GLOBAL_DEBOUNCEIDX_VALUE
#else
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GbiDebounceIdx(
   const Dem_EventIdType EventId);
#endif

#endif

/*------------------[functions for debouncing]------------------------------*/

/** \brief Reset internal status for monitor internal debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **/
extern FUNC(void, DEM_CODE) Dem_ResetDebounceMonitor(
   Dem_EventIdType EventId);

#if (DEM_USE_DEBOUNCE == STD_ON)

#if (DEM_NUM_DEBOUNCE_COUNTER > 0)
/** \brief Perform counter based debouncing for a given event
 **
 ** This function is called by the APIs Dem_ReportErrorStatus() and
 ** Dem_SetEventstatus() if counter based debouncing is enabled for the
 ** reported event.
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[in] EventStatus  status of event, either DEM_EVENT_STATUS_PREPASSED
 ** or DEM_EVENT_STATUS_PREFAILED
 **/
extern FUNC(void, DEM_CODE) Dem_DebounceEventCounterBased(
   Dem_EventIdType                                      EventId,
   P2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Return FDC for an event using counter based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[out] FDC
 **
 ** \return E_OK if FDC could be acquired, E_NOT_OK otherwise
 **/
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFDCCounterBased(
   Dem_EventIdType                                                EventId,
   P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);

/** \brief Reset internal status for counter based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **/
extern FUNC(void, DEM_CODE) Dem_ResetDebounceCounterBased(
   Dem_EventIdType EventId);
#endif

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief Perform time based debouncing for a given event
 **
 ** This function is called by the APIs Dem_ReportErrorStatus() and
 ** Dem_SetEventstatus() if time based debouncing is enabled for the
 ** reported event.
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[in] EventStatus  status of event, either DEM_EVENT_STATUS_PREPASSED
 ** or DEM_EVENT_STATUS_PREFAILED
 **/
extern FUNC(void, DEM_CODE) Dem_DebounceEventTimeBased(
   Dem_EventIdType                                      EventId,
   P2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Return FDC for an event using time based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[out] FDC
 **
 ** \return E_OK if FDC could be acquired, E_NOT_OK otherwise
 **/
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFDCTimeBased(
   Dem_EventIdType                                                EventId,
   P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);

/** \brief Reset internal status for time based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **/
extern FUNC(void, DEM_CODE) Dem_ResetDebounceTimeBased(
   Dem_EventIdType EventId);

/** \brief "Tick" the timers used for time based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **/
extern FUNC(void, DEM_CODE) Dem_DebounceTimeTimerTick(void);

#endif /* DEM_NUM_DEBOUNCE_TIME > 0U */

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief Perform frequency based debouncing for a given event
 **
 ** This function is called by the APIs Dem_ReportErrorStatus() and
 ** Dem_SetEventstatus() if frequency based debouncing is enabled for the
 ** reported event.
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[in] EventStatus  status of event, either DEM_EVENT_STATUS_PREPASSED
 ** or DEM_EVENT_STATUS_PREFAILED
 **/
extern FUNC(void, DEM_CODE) Dem_DebounceEventFrequencyBased(
   Dem_EventIdType                                      EventId,
   P2VAR(Dem_EventStatusType, AUTOMATIC, DEM_APPL_DATA) EventStatus);

/** \brief Return FDC for an event using frequency based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 ** \param[out] FDC
 **
 ** \return E_OK if FDC could be acquired, E_NOT_OK otherwise
 **/
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFDCFrequencyBased(
   Dem_EventIdType                                                EventId,
   P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA) FDC);

/** \brief Reset internal status for frequency based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **/
extern FUNC(void, DEM_CODE) Dem_ResetDebounceFrequencyBased(
   Dem_EventIdType EventId);

/** \brief "Tick" the timers used for frequency based debouncing
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **/
extern FUNC(void, DEM_CODE) Dem_DebounceFrequencyTimerTick(void);

#endif /* DEM_NUM_DEBOUNCE_FREQUENCY > 0U */
#endif /* DEM_USE_DEBOUNCE == STD_ON */

/*------------------[functions for prestore freeze frames]-------------------*/

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)

/** \brief Function to get the index of a prestored freeze frame
 **
 ** This is done by searching in the event description array.
 **
 ** ATTENTION: If an event ID where prestorage of freeze frames is disabled
 ** is given, the index of the last event where prestorage is enabled is
 ** returned.
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **
 ** \return Index of the prestored freeze frame
 **/
extern FUNC(Dem_EventIdType, DEM_CODE) Dem_GetPFFIndex(
   Dem_EventIdType EventId);

/** \brief Function to get the entry data pointer of a prestored freeze frame
 **
 ** This is done by searching in the event description array and adding all
 ** several freeze frame class sizes.
 **
 ** ATTENTION: If an event ID where prestorage of freeze frames is disabled
 ** is given, the entry data pointer of the last event where prestorage is
 ** enabled is returned.
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EventId  0 < EventId <= (DEM_NUMBER_OF_EVENTS - 1U)
 **
 ** \return Pointer to the prestored freeze frame entry data
 **/
extern FUNC(Dem_EntryDataPtrType, DEM_CODE)
   Dem_GetPFFEntryDataPtr(Dem_EventIdType EventId);

#endif /* DEM_MAX_NUMBER_PRESTORED_FF */

/** \brief Function to get start index in function pointer table and number
 ** of functions
 **/
FUNC(Std_ReturnType, DEM_CODE) Dem_GetCallbackIndex(
   Dem_EventIdType                                            EventId,
   CONSTP2CONST(Dem_CbkLookupTableType, AUTOMATIC, DEM_CONST) LookupTable,
   uint16                                                     TableSize,
   P2VAR(uint16, AUTOMATIC, DEM_VAR)                          StartIdx,
   P2VAR(uint16, AUTOMATIC, DEM_VAR)                          NumberOfCb);


/*------------------[extended data size function]---------------------------*/

#if (DEM_USE_GLOBAL_EDCLASS == STD_OFF)
/** \brief Function to get the size of an extended data by the given extended
 ** data class
 **
 ** \reentrancy    reentrant
 ** \synchronisity synchronus
 **
 ** \param[in] EDClass
 **
 ** \return Size of the extended data
 **/
extern FUNC(Dem_SizeEntryDataType, DEM_CODE) Dem_SizeOfED(
   CONSTP2CONST(Dem_EDClassType, AUTOMATIC, DEM_CONST) EDClass);
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

#define DEM_START_SEC_CONST_8BIT
#include "MemMap.h"

#if (DEM_USE_HEALING == STD_ON)
/** \brief Value of the specific extended data segment/record number for the
 ** 'healing counter'
 **/
extern CONST(uint8, DEM_CONST) Dem_HealingCounterRecNum;
#endif

#define DEM_STOP_SEC_CONST_8BIT
#include "MemMap.h"
#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/** \brief Configuration pointer table for freeze frame classes
 **
 ** Number of elements: ::DEM_NUM_FFCLS
 **/
extern CONSTP2CONST(Dem_FFClassType, DEM_CONST, DEM_CONST)
   Dem_FFClasses[DEM_NUM_FFCLS];

/** \brief Configuration pointer table for extended data classes
 **
 ** Number of elements: ::DEM_NUM_EDCLS
 **/
extern CONSTP2CONST(Dem_EDClassType, DEM_CONST, DEM_CONST)
   Dem_EDClasses[DEM_NUM_EDCLS];

/** \brief Configuration description table of DTC-group values
 **
 ** Number of elements: ::DEM_NUM_DTC_GROUPS
 **/
extern CONST(Dem_DTCGroupType, DEM_CONST) Dem_DTCGroups[DEM_NUM_DTC_GROUPS];

/** \brief Configuration description table for events
 **
 ** Number of elements: ::DEM_NUMBER_OF_EVENTS
 **
 ** This array contains all specific event-related data, which are packed by
 ** using the 'bit packing scheme'.
 **/
extern CONST(Dem_EventDescType, DEM_CONST) Dem_EventDesc[DEM_NUMBER_OF_EVENTS];

#if (DEM_USE_INDICATOR == STD_ON)
/** \brief Configuration description table for warning indicators
 **
 ** Number of elements: ::DEM_NUMBER_OF_INDICATORS
 **/
#if (DEM_NUMBER_OF_INDICATORS > 0U)
extern CONST(Dem_IndicatorDescType, DEM_CONST)
   Dem_IndicatorDesc[DEM_NUMBER_OF_INDICATORS];
#endif

/** \brief Configuration link table for warning indicator-link
 **
 ** Number of elements: ::DEM_NUM_INDICATOR_LINKS
 **/
#if (DEM_NUM_INDICATOR_LINKS > 0U)
extern CONST(Dem_IndicatorLinkType, DEM_CONST)
   Dem_IndicatorLink[DEM_NUM_INDICATOR_LINKS];
#endif
#endif /* DEM_USE_INDICATOR */

#if (DEM_USE_DEBOUNCE == STD_ON)

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief Configuration description table for counter based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_COUNTER
 **/
extern CONST(Dem_DebounceCounterCfgType, DEM_CONST)
   Dem_DebounceCounterCfg[DEM_NUM_DEBOUNCE_COUNTER];
#endif

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief Configuration description table for time based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME
 **/
extern CONST(Dem_DebounceTimeCfgType, DEM_CONST)
   Dem_DebounceTimeCfg[DEM_NUM_DEBOUNCE_TIME];
#endif

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief Configuration description table for frequency based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_FREQUENCY
 **/
extern CONST(Dem_DebounceFrequencyCfgType, DEM_CONST)
   Dem_DebounceFrequencyCfg[DEM_NUM_DEBOUNCE_FREQUENCY];
#endif

/** \brief function pointer array holding debouncing functions */
extern CONST(Dem_DebounceFctPtrTableType, DEM_CONST)
   Dem_DebounceFctPtrTable[DEM_MAXNUM_DEBOUNCECLASSES];

#endif /* DEM_USE_DEBOUNCE == STD_ON */

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Pointer to the prestored freeze frame data area */
extern CONSTP2VAR(Dem_EntryDataType, DEM_CONST, DEM_VAR_NOINIT) Dem_PFFEntryData;

#if (DEM_PFF_RUNTIME_OPTIMIZATION == STD_ON)
/** \brief pre calculated position of entry data */
extern CONST(Dem_SizeEntryDataType, DEM_CONST)
   Dem_PFFEntryDataStartPos[DEM_NBR_OF_EVENTS_WITH_PFF + 1];
#endif
#endif /* DEM_MAX_NUMBER_PRESTORED_FF */

/** \brief Event callback property table */
extern CONST(Dem_CbkPropertyType, DEM_CONST)
   Dem_CbkProperty[DEM_NUMBER_OF_EVENTS];

/*-----------------[C-Functiontable]----------------------------------------*/

#if (DEM_C_CALLBACK_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief C-Callback function pointer table for InitMonitor */
extern CONST(Dem_CbkFuncPtrInitMonitorType, DEM_CONST)
   Dem_InitMonitorCallback[DEM_C_CALLBACK_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_C_CALLBACK_TABLE_TRIGGER_ON_EVENT_SIZE != 0U)
/** \brief C-Callback function pointer table for TriggerOnEventStatus */
extern CONST(Dem_CbkFuncPtrTriggerOnEventType, DEM_CONST)
   Dem_CbkFuncPtrTriggerOnEvent[DEM_C_CALLBACK_TABLE_TRIGGER_ON_EVENT_SIZE];
#endif

#if (DEM_C_CALLBACK_TABLE_GET_FDC_SIZE != 0U)
/** \brief C-Callback function pointer table for GetFaultDetectionCounter */
extern CONST(Dem_CbkFuncPtrGetFDCType, DEM_CONST)
   Dem_CbkFuncPtrGetFaultDetectionCounter[DEM_C_CALLBACK_TABLE_GET_FDC_SIZE];
#endif

/*-----------------[C-Lookuptable]------------------------------------------*/

#if (DEM_C_LOOKUP_TABLE_TRIGGER_ON_EVENT_SIZE != 0U)
/** \brief C-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_CbkLookupTableType, DEM_CONST)
   Dem_CbkLookupTableTriggerOnEvent[DEM_C_LOOKUP_TABLE_TRIGGER_ON_EVENT_SIZE];
#endif

#if (DEM_C_LOOKUP_TABLE_GET_FDC_SIZE != 0U)
#if (DEM_C_CALLBACK_TABLE_GET_FDC_SIZE == 0U)
/** \brief C-Callback function pointer table for GetFaultDetectionCounter */
extern CONST(Dem_FDCCallbackType, DEM_CONST)
   Dem_CbkLookupTableGetFaultDetectionCounter[DEM_C_LOOKUP_TABLE_GET_FDC_SIZE];
#else
/** \brief C-Callback function lookup table for GetFaultDetectionCounter */
extern CONST(Dem_CbkLookupTableType, DEM_CONST)
   Dem_CbkLookupTableGetFaultDetectionCounter[DEM_C_LOOKUP_TABLE_GET_FDC_SIZE];
#endif /* DEM_C_CALLBACK_TABLE_GET_FDC_SIZE */
#endif /* DEM_C_LOOKUP_TABLE_GET_FDC_SIZE*/

/*-----------------[RTE-Lookuptable]----------------------------------------*/

#if (DEM_RTE_LOOKUP_TABLE_INIT_MONITOR_SIZE != 0U)
/** \brief RTE-Callback function lookup table for InitMonitor */
extern CONST(Dem_EventIdType, DEM_CONST)
   Dem_RteLookupTableInitMonitor[DEM_RTE_LOOKUP_TABLE_INIT_MONITOR_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_TRIGGER_ON_EVENT_SIZE != 0U)
/** \brief RTE-Callback function lookup table for TriggerOnEventStatus */
extern CONST(Dem_EventIdType, DEM_CONST)
   Dem_RteLookupTableTriggerOnEvent[DEM_RTE_LOOKUP_TABLE_TRIGGER_ON_EVENT_SIZE];
#endif

#if (DEM_RTE_LOOKUP_TABLE_GET_FDC_SIZE != 0U)
/** \brief RTE-Callback function lookup table for GetFaultDetectionCounter */
extern CONST(Dem_EventIdType, DEM_CONST)
   Dem_RteLookupTableGetFaultDetectionCounter[DEM_RTE_LOOKUP_TABLE_GET_FDC_SIZE];
#endif


#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"
#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"

#if (DEM_MAX_NUMBER_PRESTORED_FF > 0U)
/** \brief Flags to hold validity of the prestored freeze frames
 **
 ** Each bit represents one flag.
 **/
extern VAR(uint8, DEM_VAR_NOINIT)
   Dem_PFFEntryValid[DEM_MAX_NUMBER_PRESTORED_FF / 8U + 1U];
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"
#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

/** \brief Queue holding the errors appeared before Dem_Init(), or to be
 ** entered or updated in event memory after Dem_Init()
 **
 ** Number of elements: ::DEM_BSW_ERROR_BUFFER_SIZE
 **/
extern VAR(Dem_EventIdType, DEM_VAR_NOINIT)
   Dem_ErrorQueue[DEM_BSW_ERROR_BUFFER_SIZE];

/** \brief Array to store the current operation cycle state for all configured
 ** operating cycles
 **
 ** Number of elements: ::DEM_NUM_OPCYCLES
 **/
extern VAR(Dem_OperationCycleStateType, DEM_VAR_NOINIT)
   Dem_OpCycleState[DEM_NUM_OPCYCLES];

#if (DEM_USE_ENABLE_CONDITION == STD_ON)
/** \brief Array to store the current enable condition state for all
 ** configured enable conditions
 **
 ** Number of elements: ::DEM_NUM_ENABLECONDITIONS
 **/
extern VAR(boolean, DEM_VAR_NOINIT)
   Dem_EnableCondition[DEM_NUM_ENABLECONDITIONS];
#endif

#if (DEM_USE_DEBOUNCE == STD_ON)

#if (DEM_NUM_DEBOUNCE_COUNTER > 0U)
/** \brief per-event status for counter based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_COUNTER
 **/
extern VAR(Dem_DebounceCounterStatusType, DEM_VAR_NOINIT)
   Dem_DebounceCounterStatus[DEM_NUM_DEBOUNCE_COUNTER];
#endif

#if (DEM_NUM_DEBOUNCE_TIME > 0U)
/** \brief per-event status for time based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_TIME
 **/
extern VAR(Dem_DebounceTimeStatusType, DEM_VAR_NOINIT)
   Dem_DebounceTimeStatus[DEM_NUM_DEBOUNCE_TIME];
#endif

#if (DEM_NUM_DEBOUNCE_FREQUENCY > 0U)
/** \brief per-event status for frequency based debouncing
 **
 ** Number of elements: ::DEM_NUM_DEBOUNCE_FREQUENCY
 **/
extern VAR(Dem_DebounceFrequencyStatusType, DEM_VAR_NOINIT)
   Dem_DebounceFrequencyStatus[DEM_NUM_DEBOUNCE_FREQUENCY];
#endif

#endif /* DEM_USE_DEBOUNCE == STD_ON */


#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

/** @} doxygen end group definition */
#endif /* ifndef DEM_INTERNAL_DEPEND_H */
/*==================[end of file]===========================================*/
