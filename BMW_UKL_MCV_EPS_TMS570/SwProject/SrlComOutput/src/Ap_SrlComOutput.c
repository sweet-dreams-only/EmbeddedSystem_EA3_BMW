/**********************************************************************************************************************
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *          File:  Ap_SrlComOutput.c
 *     Workspace:  c:/Build/BMW/ses_dev_ea3/BMW_MCV_UKL_EPS_TMS570_F40_Working/BMW_UKL_MCV_EPS_TMS570/SwProject/SrlComOutput/autosar
 *     SW-C Type:  Ap_SrlComOutput
 *  Generated at:  Thu May 26 03:50:24 2016
 *
 *     Generator:  MICROSAR RTE Generator Version 2.19.1
 *       License:  License CBD1010124 valid for CBD1010124 Nxtr  Package: BMW MSR SIP BAC3.0     Micro: TI TMS570 TMS570LS30306  Compiler: Code Composer Studio 4.9.0
 *
 *   Description:  C-Code implementation template for SW-C <Ap_SrlComOutput>
 *********************************************************************************************************************/


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of version logging area >>                DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
/* Version Control:
 * Date Created:      Tue Mar 15 17:16:01 2011
 * %version:          EA3#71 %
 * %date_modified:    Thu Jan 23 11:32:12 2014 %
 *---------------------------------------------------------------------------------------------------------------------
 * Date      Rev      Author         Change Description                                                        SCR #
 * -------   -------  --------  ---------------------------------------------------------------------------  ----------
 * 02/04/11   6       JJW       Added RackLoad signal for AVL_FORC_GRD
 * 02/07/11   7       JJW       Implemented patch for RackLoad status
 * 02/07/11   8       LWW       Brought in autogenerated developer updates
 * 02/11/11   10      LWW       Added debug message and EPS Function Qualifier Signal
 * 02/14/11   11      BDO       Anomaly 2000 corrections
 * 02/15/11   12      JJW       Corrected RackLoad scale factor to account for kN scomm scaling
 * 02/15/11   13      JJW       Corrected RackLoad offset and limits to account for kN scomm scaling
 * 02/24/11   14      JJW       Corrected RackLoad scale factor anomaly 2105
 * 03/15/11   14.1.1  JJW		Template update
 * 03/16/11   15	  BDO		Apply k_SComTrqPosPol_Cnt_s8 cal to RackLoad Tx signal,							#3750
 *                              removed local copy of BMW_CRC function
 * 03/17/11   16      BDO       Transmit ElecPower_Watts in AVL_PWR_EL_EPS_COOD, QAC-Rules 10.1, 16.3 fixed.	#3619
 * 03/22/11   17      BDO       Anomaly 2097 corrections
 * 03/23/11   18      BDO       QAC rule 13.2
 * 03/26/11   19      BDO       System Framework Update
 * 03/28/11   21      JJW       EcuVoltage changed to Vecu
 * 03/30/11   22      BDO       Template upate - Coding Switch input
 * 04/05/11   23      BDO       Rename coding block to CODINGDATASET1
 * 04/06/11   24      BDO       Implement transmit data overrides based on CodingSwitch data					#3963
 * 05/13/11   24.1.1  JJW       Added metrics trace point for AVL PO EPS callout for start-up metrics
 * 05/13/11   25      BDO       Correct AVL_PWR_EL_EPS_COOD default CodingSwitch value and INVALID value        #4128, #4165
 * 05/17/11   26      BDO       JJW merged version 24.1.1 with version 25
 * 05/25/11   27      BDO       Replace generated RTE system state reported in FR_DEBUG frame with standard Nxtr system state
 * 05/26/11	  28      JJW       Template changes for Park Assist and Veh Dyn  
 * 06/03/11   29	  BDO       Update Tx Qualifiers for the Park Assist and Veh Dynamics states               	CR3611
 * 06/04/11   30	  LWW       Framework update for coding switch changes
 * 06/06/11   31	  BDO       Update names of temp variables used for Coding Function Overrides
 * 06/16/11   32	  BDO       Change transmit value of QU_FN_EST from 0xA4 to 0xA0 when in OPERATE state
 * 06/20/11   33      JJW       Added Override of Park Assist and Drive Dynamics State signals
 * 08/02/11   34      JJW       BAC3.0 Integration required signal group changes
 * 08/29/11   36      BDO       Remove ComTxPduCallout_lgc flag 
 * 09/08/11   37      BDO       Add ComTxPduCallout_lgc flag back - see anomaly 2506 for details
 * 09/16/11   38      BDO       Manually set unused bits to 1 in transmit PDUs - see anomaly 2530 for details
 * 09/16/11   39      BDO       Manually set unused bits to 1 in SuEps PDU - see above for details
 * 09/20/11   40      JJW       Added E2E integration for AVL_STMOM_AVL_STMOM_DV_ACT and AVL_STMOM_AVL_FORC_GRD
 * 09/21/11   41      JJW       Removed CRC Appl Callout for AVL_STMOM_AVL_STMOM_DV_ACT and AVL_STMOM_AVL_FORC_GRD CRC
 *                               and alive counters. E2E lib is now performing this function.
 * 09/28/11   42      BDO       Add E2E protection for AVL_PO_EPS and ST_EST PDUs 
 * 10/14/11   43      BDO       Modify RackLoad scaling															CR4555
 * 10/15/11   44      BDO       Synchronize SrlComOutput_Per1 application function to Flexray Cycle	
 * 10/16/11   45      JJW       Correct RackLoad units and scaling 
 * 10/17/11   46      BDO       Modify SrlComOutput for fast and slow transmission of the ST_EST message
 * 11/15/11   47      BDO       Add Tx confirmation functions to address anomaly 2069. 
 * 11/16/11   48      BDO       Change D_INVALIDELECPWR_CNT_U08 from 0xFF to 0x78 (0kW) - anomaly 2664
 * 12/12/11   48.1.1  JJW       Removed Rack load status signal for integration of RackLoad SF10_002.0 which no longer
 *                               provides the status signal.
 * 04/26/12   48.1.5  JJW       New ParkAssist and Drive Dynamics interface enable signals per SER
 * 06/08/12   48.1.6  BDO       Remove coding enable switches TxOvrrdQUAVLPO and TxOvrrdAVLPWR per SER 9C
 * 06/13/12   48.1.7  BDO       Update NO_CC_DRDY_02 based on indicator status signal ST_CC_DRDY_02 - CR5652
 * 06/18/12   48.1.8  BDO       Update ST_EST event handling to always transmit immediately ON CHANGE - anomaly 3333, 3368
 * 06/29/12   48.1.9  BDO       Transmit EPS Debug IPDUM frame only after ComController is Online - anomaly 3482
 * 07/10/12	  48.1.10 KJS		Added SER requirements for QU_FN_EST to calc function.
 * 07/18/12	  48.1.11 BDO		Updated SER requirements for QU_FN_EST to calc function - anomaly 3539, CR5866
 * 08/21/12	  48.1.12 BDO		Updates for anomaly 3561 and 3450
 * 08/21/12   48.1.13 BDO		Updates for anomaly 3684
 * 09/13/12   48.1.13.1.1 KJS	Updates for TEMP_CPO and Debug Frame signals and anomaly 3752
 * 09/14/12   48.1.13.1.2 KJS	Updates for anomaly 3140
 * 09/17/12   48.1.15 KJS		Merge of two files (48.1.13 & 48.1.13.1.2) back into main 350 release tag. Removed ST_EST
 * 								timing error to correct for signal timing. Issue with generation param in Developer.
 * 10/04/12	  48.1.16 KJS		Updates for anomaly 3709.
 * 10/16/12	  48.1.17 JJW		T1 and T2 inputs changed to S/R ports.
 * 10/24/12	  48.1.18 BDO		Updates for SrlComOutput and SrComOutput2 QM and ASIL_D application split. CR 6627
 * 10/26/12	  48.1.19 BDO		Move Tx COM callouts and SrlComOutput_MainFunction from SrComOutput2(ASIL_D) to SrComOutput(QM)   CR 6627
 * 10/27/12	  54	  JJW		Completed FlexRay cycle sync algorithm
 * 10/29/12	  55	  JJW		Corrected and simplified the FlexRay cycle sync algorithm
 * 10/29/12	  56	  JJW		SrlComOutput Task activation prior to first Start of Cycle ISR to ensure current is provided to the Com layer
 * 11/02/12	  57	  BDO		Modify transmission of ST_EST to ensure alive counter processing is in synch with tx rate			CR6627
 * 11/21/12	  58	  KJS		Added ports for transmission notification between SrlComOuput and SrlComOutput2
 * 03/03/13	  59	  KJS		Updated EST_BATT_AMPS to a s12p3 based on SER 11C, QAC Updates.
 * 03/15/13	  60	  KJS		Anomaly correction 4538
 * 06/26/13	  61	  KJS		Added support for Qax current in the debug frame.
 * 01/23/14	  63	  KJS		UTP clean up for anomaly 6255
 * 06/11/15	  64	  ABS		New CC-ID for Thermal Degradation CTC 0x4823FA
 * 03/09/16	  69	  ABS		QAC Correction																						EA3#6554
 * 04/26/16	  70	  ABS		Read function added for Su_Eps msg		                                                            EA3#7695
 * 05/26/16	  71	  ABS		SCIR 002A Implementation																			EA3#7977
 * 06/29/16	  72	  ABS		Updated to prevent null frames for DT_EST and proper timing trigger for SU_EPS   		  EA3#9243, EA3#9245
 * 08/08/16   73    RMV   Updated for anamolies EA3#9011, 9829  
 */
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of version logging area >>                  DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *
 * AUTOSAR Modelling Object Descriptions
 *
 **********************************************************************************************************************

 Data Types:
 ===========
  CRC8
    Standartabsicherung Apllikations-CRC.

  ID_FN_INQY
    Enthält den Identifier der angefragten Nachricht. 
     				Es sind nur die Identifier erlaubt, die als anfragbare Nachrichten definiert sind.

  UInt6
    UInt8 represents integers with a minimum value of 0 and a maximum value of 63.
     The order-relation on UInt8 is: x < y if y - x is positive.
     UInt8 has a lexical representation consisting of a finite-length sequence 
     of decimal digits (#x30-#x39). Nxtr Note: This was added for support to 
     the Edch component. The FlexRay message has 63 marked as invalid and it is also 
     reflected in this data type.


 Data Element Prototypes:
 ========================
  Volt_f32 of Port Interface Voltage_Volt_f32
    This signal is intended to communicate any type voltage signal measured by the ecu.  This signal has a lower limit of 0 which reequires users of the signal to provide divide by 0 protection if it is used as a denominator in a calculation.  See Vecu port prototype if a port with a lower limit is desired.

  Volt_f32 of Port Interface Vecu
    This port prototype is inteded to communicate voltage signals that represent the ecu supplied voltage.  This signal has a lower limit, which is non-zero, to allow users of the signal to use it as a denominator in an expression without requiring a divide by 0 check.


 Mode Declaration Groups:
 ========================
  StaMd_Mode
    EPS System State mode declaration

 *********************************************************************************************************************/

#include "Rte_Ap_SrlComOutput.h"


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of include and declaration area >>        DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
#include "Ap_SrlComOutput_Cfg.h"
#include "Com.h"
#include "Com_Cbk.h"
#include "CalConstants.h"
#include "fixmath.h"
#include "GlobalMacro.h"
#include "CheckSums.h"

#include "osek.h"
#include "CDD_Data.h"
#include "CDD_Func.h"


#include "T1_AppInterface.h"
#include "Fr.h"
#include "SchM_SrlComOutput.h"

#define D_TEMPOFFSET_DEGC_F32				40.0F

#define D_DISABLE_CNT_U08     				0x00U
#define D_OFF_CNT_U08 						0x01U
#define D_OPERATE_CNT_U08            		0x02U
#define D_WARMINIT_CNT_U08 					0x03U
#define D_TRANSITION_CNT_U08  				0x04U
#define D_INVALIDSTATE_CNT_U08  			0xFFU

/* Check Control Message */
#define D_INDICATORLAMPON_CNT_U08			1U
#define D_INDICATORLAMPOFF_CNT_U08			0U
#define D_CCMSGCOUNTER_CNT_U16              627U			/* Hardcode to 0x273 per SER */
#define D_CCMSGCOUNTER_THRMLDEGRADN_CNT_U16 0x3E5U			/* Hardcode to 997 per SER */
#define D_CCMSGCOUNTERMAX_CNT_U16 			0xFFFEU

/* EPS SETUP RequestID is 0x3404 */
#define D_BROADCASTEPSSETUP_CNT_U16			0x3404U
#define D_IDFNINQY_CNT_B16					0x01U

#define D_INITIALIZATION_CNT_U16			8U

#define D_TEMPCPO_TEMPOFFSET_CNT_F32		48.0F
#define D_TEMPCPO_LOWLMT_CNT_F32			(-48.0F)
#define D_TEMPCPO_HIGHLMT_CNT_F32			204.0F

/* Max value from SER */
#define D_FRDBG_THRMLLIMPERC_CNT_U8			0x7FU

#define D_CDISPCCEPS_MAXMASK_CNT_U08			0x03U
#define D_CDISPCCEPS_DEDICATEDMASK_CNT_U08		0x02U


#define SRLCOMOUTPUT_START_SEC_VAR_CLEARED_BOOLEAN
#include "MemMap.h"/* PRQA S 5087 */
VAR(boolean, AP_SRLCOMOUTPUT_VAR_NOINIT) ComTxPduCallout_lgc;	/* Vector ComTxPduCallout workaround */
STATIC VAR(boolean, AP_SRLCOMOUTPUT2_VAR_NOINIT) AVLFORCGRDTxConf_Cnt_M_lgc;
STATIC VAR(boolean, AP_SRLCOMOUTPUT2_VAR_NOINIT) AVLSTMOMTxConf_Cnt_M_lgc;
STATIC VAR(boolean, AP_SRLCOMOUTPUT_VAR_NOINIT) AVLPOEPSTxConf_Cnt_M_lgc;
#define SRLCOMOUTPUT_STOP_SEC_VAR_CLEARED_BOOLEAN
#include "MemMap.h"/* PRQA S 5087 */

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of include and declaration area >>          DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/


/**********************************************************************************************************************
 *
 * Used AUTOSAR Data Types
 *
 **********************************************************************************************************************
 *
 * Primitive Types:
 * ================
 * ALIV_4_BIT_Unsigned_Integer: Integer in interval [0...14]
 * AVL_FORC_GRD: Integer in interval [0...4048]
 * AVL_PINA_EPS: Integer in interval [0...65534]
 * AVL_PINA_IDX_ICM: Integer in interval [0...65534]
 * AVL_PWR_EL: Integer in interval [0...240]
 * BATT_VOLTS: Integer in interval [0...65535]
 * Boolean: Boolean (standard type)
 * CD_0x04: Integer in interval [0...15]
 * CD_0x08: Integer in interval [0...255]
 * CD_0x20: Integer in interval [0...4294967295]
 * CONT_TEMP_DEG: Integer in interval [0...255]
 * CRC8: Integer in interval [0...255]
 * DIAG_ST_OBD: Integer in interval [0...63]
 * DIFF_TRQ_NM: Integer in interval [-32768...32767]
 * EST_BATT_AMPS: Integer in interval [-32768...32767]
 * EST_CUTEMP_DEG: Integer in interval [0...255]
 * EST_MOTTEMP_DEG: Integer in interval [0...255]
 * Float: Real in interval [-FLT_MAX...FLT_MAX] with single precision (standard type)
 * MOT_VEL_RADPSEC: Integer in interval [-32768...32767]
 * MTRTRQCMD_NM: Integer in interval [-32768...32767]
 * MTRTRQLMTD_NM: Integer in interval [-32768...32767]
 * New_Coding_15: Integer in interval [0...255]
 * New_Coding_28: Integer in interval [0...65535]
 * New_Coding_3: Integer in interval [0...65535]
 * New_Coding_40: Integer in interval [0...255]
 * New_Coding_41: Integer in interval [0...14]
 * New_Coding_42: Integer in interval [0...14]
 * New_Coding_43: Integer in interval [0...65534]
 * New_Coding_45: Integer in interval [0...14]
 * New_Coding_47: Integer in interval [0...255]
 * New_Coding_48: Integer in interval [0...14]
 * New_Coding_51: Integer in interval [0...14]
 * New_Coding_52: Integer in interval [0...255]
 * OFFS_GRD_MID_EPS: Integer in interval [0...4094]
 * STMOM_QTA_DV: Integer in interval [0...4000]
 * ST_DIAG_OBD_MUX_MAX: Integer in interval [0...60]
 * SWA_DEG: Integer in interval [-32768...32767]
 * THRML_LIMIT_PERC: Integer in interval [0...1]
 * TORQUE1_VOLTS: Integer in interval [0...65535]
 * TORQUE2_VOLTS: Integer in interval [0...65535]
 * TOT_STR_EPS: Integer in interval [0...4094]
 * UInt16: Integer in interval [0...65535] (standard type)
 * UInt4: Integer in interval [0...15] (standard type)
 * UInt6: Integer in interval [0...63]
 * UInt8: Integer in interval [0...255] (standard type)
 *
 * Enumeration Types:
 * ==================
 * ALIV_COU_4: Enumeration of integer in interval [0...15] with enumerators
 *   CxF_Signal_ungueltig (15U)
 * ComM_ModeType: Enumeration of integer in interval [0...2] with enumerators
 *   COMM_NO_COMMUNICATION (0U)
 *   COMM_SILENT_COMMUNICATION (1U)
 *   COMM_FULL_COMMUNICATION (2U)
 * Dem_IndicatorStatusType: Enumeration of integer in interval [0...3] with enumerators
 *   DEM_INDICATOR_OFF (0U)
 *   DEM_INDICATOR_CONTINUOUS (1U)
 *   DEM_INDICATOR_BLINKING (2U)
 *   DEM_INDICATOR_BLINK_CONT (3U)
 * IDX_TORQ_SEN: Enumeration of integer in interval [0...3] with enumerators
 *   Cx0_Initialisierung (0U)
 *   Cx1_Keine_Index_Flanke (1U)
 *   Cx2_Index_Flanke (2U)
 *   Cx3_Signal_ungueltig (3U)
 * ID_FN_INQY: Enumeration of integer in interval [0...65535] with enumerators
 *   Cx03EB_Grenzwerte_Schwenk_Links (1003U)
 *   Cx03EC_Grenzwerte_Schwenk_Rechts (1004U)
 *   Cx03F1_Status_Licht_Erweitert_CKM (1009U)
 *   Cx03F5_Status_Laderaumabdeckung_CKM (1013U)
 *   Cx0424_Status_Konfiguration_Kombi (1060U)
 *   Cx0427_Konfiguration_DSC (1063U)
 *   Cx042E_Status_M_Drive_2 (1070U)
 *   Cx0434_Konfiguration_EPS (1076U)
 *   Cx0435_Messung_Motoroel (1077U)
 *   Cx043F_Identifikationsnummer_Sensorcluster (1087U)
 *   Cx00A1_Bedienung_Tasten_Entertainment (161U)
 *   Cx00F6_Steuerung_Aussenspiegel (246U)
 *   Cx01AA_Effekt_ErgoCommander (426U)
 *   Cx01AE_Effekt_FondCommander (430U)
 *   Cx020D_Position_Lenksaeule (525U)
 *   Cx0226_Regensensor_Wischergeschwindigkeit (550U)
 *   Cx023A_Status_Funkschluessel (570U)
 *   Cx0248_Status_Rueckfahrkamera (584U)
 *   Cx0252_Wischerstatus (594U)
 *   Cx0267_Bedienung_Tastgeber_Bedienelement_Front (615U)
 *   Cx027E_Status_Verdeck_Cabrio (638U)
 *   CxFFFF_Signal_ungueltig (65535U)
 *   Cx0291_Bedienung_Einheiten (657U)
 *   Cx02E6_Status_Klima_Luftverteilung_FA (742U)
 *   Cx02EA_Status_Klima_Luftverteilung_BF (746U)
 *   Cx02EC_Status_Klima_SH_ZH_Zusatzwasserpumpe (748U)
 *   Cx02EE_Status_Klima_Zusatzprogramme (750U)
 *   Cx02F0_Status_Klima_Standfunktionen (752U)
 *   Cx02F7_Einheiten (759U)
 *   Cx02F8_Uhrzeit_Datum (760U)
 *   Cx0300_Status_RSE (768U)
 *   Cx030F_Status_Service_Call_TeleX (783U)
 *   Cx0313_Status_Service_Call_Teleservice (787U)
 *   Cx0332_Verbrauch_Information_Daten (818U)
 *   Cx0336_Anzeige_Checkcontrol_Meldung__Rolle_ (822U)
 *   Cx033A_Status_Monitor_Front (826U)
 *   Cx033C_Status_Monitor_Fond_1 (828U)
 *   Cx033E_Status_Monitor_Fond_2 (830U)
 *   Cx0341_Status_Kartendaten (833U)
 *   Cx0349_Rohdaten_Fuellstand_Tank (841U)
 *   Cx035C_Status_Bordcomputer (860U)
 *   Cx0360_Daten_Bordcomputer__Fahrtbeginn_ (864U)
 *   Cx0380_Fahrgestellnummer (896U)
 *   Cx0381_Elektronischer_Motoroelmessstab (897U)
 *   Cx0382_Elektronischer_Motoroelmessstab_M (898U)
 *   Cx0388_Fahrzeugtyp (904U)
 *   Cx038E_Startdrehzahl (910U)
 *   Cx0395_Codierung_Powermanagement (917U)
 *   Cx0399_Status_M_Drive (921U)
 *   Cx03A9_Status_Motorsteuerung_CKM (937U)
 *   Cx03AB_Status_Shiftlights_CKM (939U)
 *   Cx03B6_Position_Fensterheber_FAT (950U)
 *   Cx03B7_Position_Fensterheber_FATH (951U)
 *   Cx03B8_Position_Fensterheber_BFT (952U)
 *   Cx03B9_Position_Fensterheber_BFTH (953U)
 *   Cx03BA_Position_SHD (954U)
 *   Cx03BC_Position_Fensterheber_Sicherheitsfahrzeug (956U)
 *   Cx03BF_Position_Fensterheber_Heckscheibe (959U)
 *   Cx03C0_Konfiguration_FAS (960U)
 *   Cx03C1_Konfiguration_BFS (961U)
 *   Cx03C2_Konfiguration_FASH (962U)
 *   Cx03C3_Konfiguration_BFSH (963U)
 *   Cx03C4_Status_EDCK_CKM (964U)
 *   Cx03D0_Status_Spurverlassenswarnsystem_CKM (976U)
 *   Cx03D5_Status_Zentralverriegelung_CKM (981U)
 *   Cx03D7_Status_DWA_CKM (983U)
 *   Cx03D9_Status_RLS_CKM (985U)
 *   Cx03DB_Status_Memorypositionen_CKM (987U)
 *   Cx03DD_Status_Licht_CKM (989U)
 *   Cx03DF_Status_Klima_CKM (991U)
 *   Cx03E1_Status_ALC_CKM (993U)
 *   Cx03E3_Status_Heckklappe_CKM (995U)
 *   Cx03E5_Status_Rueckfahrkamera_CKM (997U)
 * ID_TEMP_CPO_HET_MNG: Enumeration of integer in interval [0...15] with enumerators
 *   Cx1_EPS_Motortemperatur (1U)
 *   CxD_Reserviert (13U)
 *   CxE_Reserviert (14U)
 *   CxF_Signal_unbefuellt (15U)
 * NTCNumber: Enumeration of integer in interval [0...511] with enumerators
 *   NTC_Num_FlashWrapperLgcFlt (1U)
 *   NTC_Num_FlashECCCorr (2U)
 *   NTC_Num_FlashECCMemFlt (3U)
 *   NTC_Num_FlashCRCMemFault (4U)
 *   NTC_Num_NvMBlkDftActA (6U)
 *   NTC_Num_NvMBlkDftActB (7U)
 *   NTC_Num_NvMBlkDftActC (8U)
 *   NTC_Num_CurrentSensorCalOutOfRange (9U)
 *   NTC_Num_EEPROMDiag (10U)
 *   NTC_Num_EEPROMDiagMtrStr (11U)
 *   NTC_Num_PriSnsrTrqStorFlt (12U)
 *   NTC_Num_EEPROMDiagPosTrimStr (13U)
 *   NTC_Num_SecSnsrTrqStorFlt (14U)
 *   NTC_Num_EEPROMDiagPolarityStr (15U)
 *   NTC_Num_RAMDiag_GeneralFlt (16U)
 *   NTC_Num_RAMDiag_WrprLgcFlt (17U)
 *   NTC_Num_RAMDiag_ECCCorrIndFlt (18U)
 *   NTC_Num_RAMDiag_ECCMemFlt (19U)
 *   NTC_Num_RAMDiag_CRCMemFlt (20U)
 *   NTC_Num_RAMDiag_VIMRamFlt (23U)
 *   NTC_Num_RAMDiag_NHET1RamFlt (24U)
 *   NTC_Num_RAMDiag_NHET2RamFlt (25U)
 *   NTC_Num_RAMDiag_ADC1RamFlt (26U)
 *   NTC_Num_RAMDiag_DCANRamFault (27U)
 *   NTC_Num_RAMDiag_ADC2RamFlt (28U)
 *   NTC_Num_RAMDiag_HETTU1RamFlt (29U)
 *   NTC_Num_RAMDiag_HETTU2RamFlt (30U)
 *   NTC_Num_CPU_RegVer (32U)
 *   NTC_Num_CPU_CoreInitFlt (33U)
 *   NTC_Num_CPU_CoreRunTimeFlt (34U)
 *   NTC_Num_CPU_ClockMon (35U)
 *   NTC_Num_CPU_eFuseFlt (36U)
 *   NTC_Num_CPU_MPUViolation (37U)
 *   NTC_Num_CPU_FactPrcsErr (40U)
 *   NTC_Num_PropExeDiag_InitDiag (41U)
 *   NTC_Num_PrgFlwDeadlnFlt (42U)
 *   NTC_Num_PropExeDiag_RunTimeDiag (43U)
 *   NTC_Num_PropExeDiag_COPTimeout (44U)
 *   NTC_Num_PropExeDiag_PrefetchAbort (48U)
 *   NTC_Num_PropExeDiag_DataAbort (49U)
 *   NTC_Num_PerDiag_ADC1Flt (50U)
 *   NTC_Num_PerDiag_ADC2Flt (51U)
 *   NTC_Num_PerDiag_ADCCrossChkFlt (52U)
 *   NTC_Num_PerDiag_IllegalAccess (53U)
 *   NTC_Num_PerDiag_DMAFlt (54U)
 *   NTC_Num_PeripheralStartupFlt (55U)
 *   NTC_Num_PerDiag_CPUWarning (63U)
 *   NTC_Num_TmpMonFunc (64U)
 *   NTC_Num_TmpMonRunTimeFlt (65U)
 *   NTC_Num_PowerRelayInitFlt (66U)
 *   NTC_Num_PrechargeFailure (67U)
 *   NTC_Num_PowerRelayRunFlt (68U)
 *   NTC_Num_Thermistor (69U)
 *   NTC_Num_RefSupplyVltg (70U)
 *   NTC_Num_TrcvrInterfaceFlt (71U)
 *   NTC_Num_CPUSupplyOvervoltage (72U)
 *   NTC_Num_BattVltgMeasdCorrlnFlt (73U)
 *   NTC_Num_IvtrPwrDiscnctFailr (74U)
 *   NTC_Num_PowerRelayInit2Flt (75U)
 *   NTC_Num_GateDrvFltInProcess (76U)
 *   NTC_Num_GateDrvFlt (77U)
 *   NTC_Num_OnStateSingleFET (78U)
 *   NTC_Num_OnStateMultiFET (79U)
 *   NTC_Num_PhaseVoltageVerf (80U)
 *   NTC_Num_PhaseDscnt (81U)
 *   NTC_Num_DigPhaseVoltageVerf (82U)
 *   NTC_Num_PhaseDscntFailedDisable (83U)
 *   NTC_Num_CurrentMeas1 (84U)
 *   NTC_Num_CurrentMeas2 (85U)
 *   NTC_Num_CurrentMeasCrossChk (86U)
 *   NTC_Num_PDSupplyOverVoltage (87U)
 *   NTC_Num_ChargePumpUnderVoltage (88U)
 *   NTC_Num_Inv2GateDrvFltInProcess (92U)
 *   NTC_Num_Inv2GateDrvFlt (93U)
 *   NTC_Num_Inv2OnStateSingleFET (94U)
 *   NTC_Num_HwTrqSensor (96U)
 *   NTC_Num_AnaVsDigHwTrq (97U)
 *   NTC_Num_TrqSensorRecoveryFlt (98U)
 *   NTC_Num_TrqSensorScaleInvalid (100U)
 *   NTC_Num_T1vsT2 (101U)
 *   NTC_Num_T1OutofRange (102U)
 *   NTC_Num_T2OutofRange (103U)
 *   NTC_Num_DigT1vsT2 (104U)
 *   NTC_Num_DigT1OutofRange (105U)
 *   NTC_Num_DigT2OutofRange (106U)
 *   NTC_Num_RedT1vsT2 (107U)
 *   NTC_Num_HWACrossChecks (108U)
 *   NTC_Num_HWASnsrCommFault (109U)
 *   NTC_Num_HWASensorRel (110U)
 *   NTC_Num_HWASensorAbs (111U)
 *   NTC_Num_PriMSB_SinCosCorr (112U)
 *   NTC_Num_SecMSB_SinCosCorr (113U)
 *   NTC_Num_PriVsSec_SinCosCorr (114U)
 *   NTC_Num_DigMSBFlt (115U)
 *   NTC_Num_MtrVelFlt (116U)
 *   NTC_Num_HWAtoMtrAngleCorr (117U)
 *   NTC_Num_RedPriVsSec_SinCosCorr (118U)
 *   NTC_Num_TurnCntr_PosLoss (128U)
 *   NTC_Num_TurnCntr_MicroProcFlt (129U)
 *   NTC_Num_TurnCntr_SensorPosFlt (130U)
 *   NTC_Num_TurnCntr_SpiComFlt (131U)
 *   NTC_Num_TurnCntr_HighQuiescCur (132U)
 *   NTC_Num_TurnCntr_MainResets (133U)
 *   NTC_Num_TurnCntr_PosLossNotSpdDep (134U)
 *   NTC_Num_KinematicIntDiag (144U)
 *   NTC_Num_HighFriction (145U)
 *   NTC_Num_DutyCycleExceeded (148U)
 *   NTC_Num_AbsTempThermLimit (149U)
 *   NTC_Num_LatchActive (160U)
 *   NTC_Num_OpTrqVsHwTrq (168U)
 *   NTC_Num_CurrentReas (169U)
 *   NTC_Num_LoaRpdShutdn (170U)
 *   NTC_Num_LoaCtrldShutdn (171U)
 *   NTC_Num_LoaMgr_HwTqIdptSigTooLow (172U)
 *   NTC_Num_LoaMgr_MotAgIdptSigTooLow (173U)
 *   NTC_Num_LoaMgr_MotCurrIdptSigTooLow (174U)
 *   NTC_Num_LoaMgr_IvtrIdptSigTooLow (175U)
 *   NTC_Num_OpVoltage (176U)
 *   NTC_Num_ExVoltageLow (177U)
 *   NTC_Num_ReducedAsstLowVoltage (178U)
 *   NTC_Num_ExVoltageHigh (180U)
 *   NTC_Num_OpVoltageOvrMax (181U)
 *   NTC_Num_BattTransOverVolt (182U)
 *   NTC_Num_IgnConfDiag (184U)
 *   NTC_Num_TurnCntr_LowBattery (185U)
 *   NTC_Num_EEPROMCloseFailed (191U)
 *   NTC_Num_SigPath1CrossChk (192U)
 *   NTC_Num_SigPath2CrossChk (193U)
 *   NTC_Num_SigPath3CrossChk (194U)
 *   NTC_Num_SigPath4CrossChk (195U)
 *   NTC_Num_SigPath5CrossChk (196U)
 *   NTC_Num_DampingFWReached (197U)
 *   NTC_Num_AssistFWReached (198U)
 *   NTC_Num_ReturnFWReached (199U)
 *   NTC_Num_DampingFWFltMode (200U)
 *   NTC_Num_AssistFWFltMode (201U)
 *   NTC_Num_VBICFltMode (202U)
 *   NTC_Num_StaMdsSysC (203U)
 *   NTC_NUM_SysFailureForRotVel (204U)
 *   NTC_NUM_SysFailForRedntRotVel (205U)
 *   NTC_Num_SysFailureForTrqSnsr (206U)
 *   NTC_Num_SysFailureForRedTrqSnsr (207U)
 *   NTC_NUM_SysFailureForCtrlVolt (209U)
 *   NTC_Num_GlblSgnlOvrwrtDet (223U)
 *   NTC_Num_VLF_00 (224U)
 *   NTC_Num_VLF_01 (225U)
 *   NTC_Num_VLF_02 (226U)
 *   NTC_Num_VLF_03 (227U)
 *   NTC_Num_VLF_04 (228U)
 *   NTC_Num_VLF_05 (229U)
 *   NTC_Num_VLF_06 (230U)
 *   NTC_Num_VLF_07 (231U)
 *   NTC_Num_VLF_08 (232U)
 *   NTC_Num_VLF_09 (233U)
 *   NTC_Num_VLF_10 (234U)
 *   NTC_Num_VLF_11 (235U)
 *   NTC_Num_VLF_12 (236U)
 *   NTC_Num_VLF_13 (237U)
 *   NTC_Num_VLF_14 (238U)
 *   NTC_Num_VLF_15 (239U)
 *   NTC_Num_VLF_16 (240U)
 *   NTC_Num_VLF_17 (241U)
 *   NTC_Num_VLF_18 (242U)
 *   NTC_Num_VLF_19 (243U)
 *   NTC_Num_VLF_20 (244U)
 *   NTC_Num_VLF_21 (245U)
 *   NTC_Num_VLF_22 (246U)
 *   NTC_Num_VLF_23 (247U)
 *   NTC_Num_VLF_24 (248U)
 *   NTC_Num_VLF_25 (249U)
 *   NTC_Num_VLF_26 (250U)
 *   NTC_Num_VLF_27 (251U)
 *   NTC_Num_VLF_28 (252U)
 *   NTC_Num_VLF_29 (253U)
 *   NTC_Num_VLF_30 (254U)
 *   NTC_Num_VLF_31 (255U)
 *   NTC_Num_BusOffCh1 (256U)
 *   NTC_Num_BusOffCh1NodeMute (257U)
 *   NTC_Num_Node1AAbsent (258U)
 *   NTC_Num_Node1AFaulty (259U)
 *   NTC_Num_Node1BAbsent (260U)
 *   NTC_Num_Node1BFaulty (261U)
 *   NTC_Num_Node1CAbsent (262U)
 *   NTC_Num_Node1CFaulty (263U)
 *   NTC_Num_Node1DAbsent (264U)
 *   NTC_Num_Node1DFaulty (265U)
 *   NTC_Num_Node1EAbsent (266U)
 *   NTC_Num_Node1EFaulty (267U)
 *   NTC_Num_Node1FAbsent (268U)
 *   NTC_Num_Node1FFaulty (269U)
 *   NTC_Num_Node1GAbsent (270U)
 *   NTC_Num_Node1GFaulty (271U)
 *   NTC_Num_BusOffCh2 (272U)
 *   NTC_Num_Node2AAbsent (273U)
 *   NTC_Num_Node2AFaulty (274U)
 *   NTC_Num_Node2BAbsent (275U)
 *   NTC_Num_Node2BFaulty (276U)
 *   NTC_Num_Node2CAbsent (277U)
 *   NTC_Num_Node2CFaulty (278U)
 *   NTC_Num_Node2DAbsent (279U)
 *   NTC_Num_Node2DFaulty (280U)
 *   NTC_Num_Node2EAbsent (281U)
 *   NTC_Num_Node2EFaulty (282U)
 *   NTC_Num_Node2FAbsent (283U)
 *   NTC_Num_Node2FFaulty (284U)
 *   NTC_Num_Node2GAbsent (285U)
 *   NTC_Num_Node2GFaulty (286U)
 *   NTC_Num_InvalidMsg_M (288U)
 *   NTC_Num_MissingMsg_M (289U)
 *   NTC_Num_CRCFltMsg_M (290U)
 *   NTC_Num_PgrsCntFltMsg_M (291U)
 *   NTC_Num_DataRngFltMsg_M (292U)
 *   NTC_Num_DataRateFltMsg_M (293U)
 *   NTC_Num_DataOtherFltMsg_M (294U)
 *   NTC_Num_DataOther2FltMsg_M (295U)
 *   NTC_Num_InvalidMsg_N (296U)
 *   NTC_Num_MissingMsg_N (297U)
 *   NTC_Num_CRCFltMsg_N (298U)
 *   NTC_Num_PgrsCntFltMsg_N (299U)
 *   NTC_Num_DataRngFltMsg_N (300U)
 *   NTC_Num_DataRateFltMsg_N (301U)
 *   NTC_Num_DataOtherFltMsg_N (302U)
 *   NTC_Num_DataOtherFlt2Msg_N (303U)
 *   NTC_Num_InvalidMsg_O (304U)
 *   NTC_Num_MissingMsg_O (305U)
 *   NTC_Num_CRCFltMsg_O (306U)
 *   NTC_Num_PgrsCntFltMsg_O (307U)
 *   NTC_Num_DataRngFltMsg_O (308U)
 *   NTC_Num_DataRateFltMsg_O (309U)
 *   NTC_Num_DataOtherFltMsg_O (310U)
 *   NTC_Num_InvalidMsg_P (312U)
 *   NTC_Num_MissingMsg_P (313U)
 *   NTC_Num_CRCFltMsg_P (314U)
 *   NTC_Num_PgrsCntFltMsg_P (315U)
 *   NTC_Num_DataRngFltMsg_P (316U)
 *   NTC_Num_DataRateFltMsg_P (317U)
 *   NTC_Num_DataOtherFltMsg_P (318U)
 *   NTC_Num_InvalidMsg_Q (320U)
 *   NTC_Num_MissingMsg_Q (321U)
 *   NTC_Num_CRCFltMsg_Q (322U)
 *   NTC_Num_PgrsCntFltMsg_Q (323U)
 *   NTC_Num_DataRngFltMsg_Q (324U)
 *   NTC_Num_DataRateFltMsg_Q (325U)
 *   NTC_Num_DataOtherFltMsg_Q (326U)
 *   NTC_Num_InvalidMsg_R (328U)
 *   NTC_Num_MissingMsg_R (329U)
 *   NTC_Num_CRCFltMsg_R (330U)
 *   NTC_Num_PgrsCntFltMsg_R (331U)
 *   NTC_Num_DataRngFltMsg_R (332U)
 *   NTC_Num_DataRateFltMsg_R (333U)
 *   NTC_Num_DataOtherFltMsg_R (334U)
 *   NTC_Num_DataOtherFlt2Msg_R (335U)
 *   NTC_Num_InvalidMsg_S (336U)
 *   NTC_Num_MissingMsg_S (337U)
 *   NTC_Num_CRCFltMsg_S (338U)
 *   NTC_Num_PgrsCntFltMsg_S (339U)
 *   NTC_Num_DataRngFltMsg_S (340U)
 *   NTC_Num_DataRateFltMsg_S (341U)
 *   NTC_Num_DataOtherFltMsg_S (342U)
 *   NTC_Num_InvalidMsg_T (344U)
 *   NTC_Num_MissingMsg_T (345U)
 *   NTC_Num_CRCFltMsg_T (346U)
 *   NTC_Num_PgrsCntFltMsg_T (347U)
 *   NTC_Num_DataRngFltMsg_T (348U)
 *   NTC_Num_DataRateFltMsg_T (349U)
 *   NTC_Num_DataOtherFltMsg_T (350U)
 *   NTC_Num_InvalidMsg_U (352U)
 *   NTC_Num_MissingMsg_U (353U)
 *   NTC_Num_CRCFltMsg_U (354U)
 *   NTC_Num_PgrsCntFltMsg_U (355U)
 *   NTC_Num_DataRngFltMsg_U (356U)
 *   NTC_Num_DataRateFltMsg_U (357U)
 *   NTC_Num_DataOtherFltMsg_U (358U)
 *   NTC_Num_InvalidMsg_V (360U)
 *   NTC_Num_MissingMsg_V (361U)
 *   NTC_Num_CRCFltMsg_V (362U)
 *   NTC_Num_PgrsCntFltMsg_V (363U)
 *   NTC_Num_DataRngFltMsg_V (364U)
 *   NTC_Num_DataRateFltMsg_V (365U)
 *   NTC_Num_DataOtherFltMsg_V (366U)
 *   NTC_Num_InvalidMsg_W (368U)
 *   NTC_Num_MissingMsg_W (369U)
 *   NTC_Num_CRCFltMsg_W (370U)
 *   NTC_Num_PgrsCntFltMsg_W (371U)
 *   NTC_Num_DataRngFltMsg_W (372U)
 *   NTC_Num_DataRateFltMsg_W (373U)
 *   NTC_Num_DataOtherFltMsg_W (374U)
 *   NTC_Num_InvalidMsg_X (376U)
 *   NTC_Num_MissingMsg_X (377U)
 *   NTC_Num_CRCFltMsg_X (378U)
 *   NTC_Num_PgrsCntFltMsg_X (379U)
 *   NTC_Num_DataRngFltMsg_X (380U)
 *   NTC_Num_DataRateFltMsg_X (381U)
 *   NTC_Num_DataOtherFltMsg_X (382U)
 *   NTC_Num_InvalidMsg_Y (384U)
 *   NTC_Num_MissingMsg_Y (385U)
 *   NTC_Num_CRCFltMsg_Y (386U)
 *   NTC_Num_PgrsCntFltMsg_Y (387U)
 *   NTC_Num_DataRngFltMsg_Y (388U)
 *   NTC_Num_DataRateFltMsg_Y (389U)
 *   NTC_Num_DataOtherFltMsg_Y (390U)
 *   NTC_Num_InvalidMsg_Z (392U)
 *   NTC_Num_MissingMsg_Z (393U)
 *   NTC_Num_CRCFltMsg_Z (394U)
 *   NTC_Num_PgrsCntFltMsg_Z (395U)
 *   NTC_Num_DataRngFltMsg_Z (396U)
 *   NTC_Num_DataRateFltMsg_Z (397U)
 *   NTC_Num_DataOtherFltMsg_Z (398U)
 *   NTC_Num_DSTXORActive (399U)
 *   NTC_Num_InvalidMsg_AA (400U)
 *   NTC_Num_MissingMsg_AA (401U)
 *   NTC_Num_CRCFltMsg_AA (402U)
 *   NTC_Num_PgrsCntFltMsg_AA (403U)
 *   NTC_Num_DataRngFltMsg_AA (404U)
 *   NTC_Num_DataRateFltMsg_AA (405U)
 *   NTC_Num_DataOtherFltMsg_AA (406U)
 *   NTC_Num_InvalidMsg_AB (408U)
 *   NTC_Num_MissingMsg_AB (409U)
 *   NTC_Num_CRCFltMsg_AB (410U)
 *   NTC_Num_PgrsCntFltMsg_AB (411U)
 *   NTC_Num_DataRngFltMsg_AB (412U)
 *   NTC_Num_DataRateFltMsg_AB (413U)
 *   NTC_Num_DataOtherFltMsg_AB (414U)
 *   NTC_Num_InvalidMsg_AC (416U)
 *   NTC_Num_MissingMsg_AC (417U)
 *   NTC_Num_CRCFltMsg_AC (418U)
 *   NTC_Num_PgrsCntFltMsg_AC (419U)
 *   NTC_Num_DataRngFltMsg_AC (420U)
 *   NTC_Num_DataRateFltMsg_AC (421U)
 *   NTC_Num_DataOtherFltMsg_AC (422U)
 *   NTC_Num_InvalidMsg_AD (424U)
 *   NTC_Num_MissingMsg_AD (425U)
 *   NTC_Num_CRCFltMsg_AD (426U)
 *   NTC_Num_PgrsCntFltMsg_AD (427U)
 *   NTC_Num_DataRngFltMsg_AD (428U)
 *   NTC_Num_DataRateFltMsg_AD (429U)
 *   NTC_Num_DataOtherFltMsg_AD (430U)
 *   NTC_Num_InvalidMsg_AE (432U)
 *   NTC_Num_MissingMsg_AE (433U)
 *   NTC_Num_CRCFltMsg_AE (434U)
 *   NTC_Num_PgrsCntFltMsg_AE (435U)
 *   NTC_Num_DataRngFltMsg_AE (436U)
 *   NTC_Num_DataRateFltMsg_AE (437U)
 *   NTC_Num_DataOtherFltMsg_AE (438U)
 *   NTC_Num_InvalidMsg_AF (440U)
 *   NTC_Num_MissingMsg_AF (441U)
 *   NTC_Num_CRCFltMsg_AF (442U)
 *   NTC_Num_PgrsCntFltMsg_AF (443U)
 *   NTC_Num_DataRngFltMsg_AF (444U)
 *   NTC_Num_DataRateFltMsg_AF (445U)
 *   NTC_Num_DataOtherFltMsg_AF (446U)
 *   NTC_Num_InvalidMsg_AG (448U)
 *   NTC_Num_MissingMsg_AG (449U)
 *   NTC_Num_CRCFltMsg_AG (450U)
 *   NTC_Num_PgrsCntFltMsg_AG (451U)
 *   NTC_Num_DataRngFltMsg_AG (452U)
 *   NTC_Num_DataRateFltMsg_AG (453U)
 *   NTC_Num_DataOtherFltMsg_AG (454U)
 *   NTC_Num_InvalidMsg_AH (456U)
 *   NTC_Num_MissingMsg_AH (457U)
 *   NTC_Num_CRCFltMsg_AH (458U)
 *   NTC_Num_PgrsCntFltMsg_AH (459U)
 *   NTC_Num_DataRngFltMsg_AH (460U)
 *   NTC_Num_DataRateFltMsg_AH (461U)
 *   NTC_Num_DataOtherFltMsg_AH (462U)
 *   NTC_Num_InvalidMsg_ParkAssistParallel (464U)
 *   NTC_Num_FlexrayCommunicationError (465U)
 *   NTC_Num_InvalidMsg_AI (466U)
 *   NTC_Num_MissingMsg_AI (467U)
 *   NTC_Num_InvalidMsg_AJ (472U)
 *   NTC_Num_MissingMsg_AJ (473U)
 *   NTC_Num_InvalidMsg_AK (480U)
 *   NTC_Num_MissingMsg_AK (481U)
 *   NTC_Num_MissingMsg_AL (489U)
 *   NTC_Num_SysConsistencyVerf (496U)
 *   NTC_Num_ConfigMisMatch (497U)
 *   NTC_Num_CalNotPrgmd (498U)
 *   NTC_Num_TunSetNotPrgmd (499U)
 *   NTC_Num_EEPROMtoFeeCpyError (500U)
 *   NTC_Num_EOLVehTunNtPerf (501U)
 *   NTC_Num_MtrSensorNotTrimmed (502U)
 *   NTC_Num_HWASensorNotTrimmed (504U)
 *   NTC_Num_HWASensorTrimNoAttempt (505U)
 *   NTC_Num_TrqSensorScaleNotSet (506U)
 *   NTC_Num_TrqSensorNotTrimmed (507U)
 *   NTC_Num_AnaHWDiffTqOfstNotTrmd (508U)
 *   NTC_Num_DigTrqSensorScaleNotSet (509U)
 *   NTC_Num_DigTrqSensorNotTrimmed (510U)
 *   NTC_Num_SENTHWDiffTqOfstNotTrmd (511U)
 * New_Coding_39: Enumeration of integer in interval [0...4095] with enumerators
 *   CxFFD_Funktionsschnittstelle_ist_nicht_verfuegbar (4093U)
 *   CxFFE_Funktion_meldet_Fehler (4094U)
 *   CxFFF_Signal_unbefuellt (4095U)
 * New_Coding_44: Enumeration of integer in interval [0...3] with enumerators
 *   Cx0_Kein_Blinken (0U)
 *   Cx1_Langsames_Blinken (1U)
 *   Cx2_Schnelles_Blinken (2U)
 *   Cx3_Signal_ungueltig (3U)
 * New_Coding_46: Enumeration of integer in interval [0...3] with enumerators
 *   Cx0_Ruecksetzen (0U)
 *   Cx1_Setzen (1U)
 *   Cx3_Signal_ungueltig (3U)
 * New_Coding_49: Enumeration of integer in interval [0...255] with enumerators
 *   CxFD_Funktionsschnittstelle_ist_nicht_verfuegbar (253U)
 *   CxFE_Funktion_meldet_Fehler (254U)
 *   CxFF_Signal_unbefuellt (255U)
 * New_Coding_50: Enumeration of integer in interval [0...15] with enumerators
 *   Cx1_Funktion_verfuegbar_nicht_aktiv (1U)
 *   Cx6_Fehler (6U)
 *   Cx9_Funktion_verfuegbar_aktiv (9U)
 *   CxE_Funktion_nicht_verfuegbar (14U)
 *   CxF_Signal_unbefuellt (15U)
 * NxtrDiagMgrStatus: Enumeration of integer in interval [0...255] with enumerators
 *   NTC_STATUS_PASSED (0U)
 *   NTC_STATUS_FAILED (1U)
 *   NTC_STATUS_PREPASSED (2U)
 *   NTC_STATUS_PREFAILED (3U)
 * QU_AVL_FORC_GRD: Enumeration of integer in interval [0...15] with enumerators
 *   Cx2_Signalwert_ist_gueltig (2U)
 *   Cx8_Initialisierung (8U)
 *   CxE_Signalwert_ist_ungueltig__Zustand_Status_temporaer (14U)
 *   CxF_Signal_ungueltig (15U)
 * QU_AVL_PINA_EPS: Enumeration of integer in interval [0...15] with enumerators
 *   Cx1_Signalwert_ist_gueltig_und_abgesichert_und_plausibilisiert (1U)
 *   Cx2_Signalwert_ist_gueltig (2U)
 *   Cx4_Ersatzwert_ist_im_Nutzsignal_gesetzt (4U)
 *   Cx8_Initialisierung (8U)
 *   CxA_Signalwert_ist_gueltig__Zustand_Status_temporaer (10U)
 *   CxC_Abgleichwert_ist_im_Nutzsignal_gesetzt___Zustand_Status_temporaer (12U)
 *   CxE_Signalwert_ist_ungueltig__Zustand_Status_temporaer (14U)
 *   CxF_Signal_ungueltig (15U)
 * QU_AVL_STMOM_DV_ACT: Enumeration of integer in interval [0...15] with enumerators
 *   Cx1_Signalwert_ist_gueltig_und_abgesichert_und_plausibilisiert (1U)
 *   Cx6_Signalwert_ist_ungueltig (6U)
 *   Cx8_Initialisierung (8U)
 *   CxE_Signalwert_ist_ungueltig__Zustand_Status_temporaer (14U)
 *   CxF_Signal_ungueltig (15U)
 * QU_FN_EST: Enumeration of integer in interval [0...255] with enumerators
 *   Cx31_Funktion_in_Rueckfallebene (49U)
 *   Cx33_Funktion_in_Rueckfallebene__Notfallfunktion_Umwelteinfluesse__Aktiv (51U)
 *   Cx60_Funktion_nicht_verfuegbar___Fehler (96U)
 *   Cx80_Initialisierung (128U)
 *   CxA0_Funktion_verfuegbar___Aktiv__12V_EPS (160U)
 *   CxA2_Funktion_verfuegbar___Aktiv__Notfallfunktion_Umwelteinfluesse___Aktiv (162U)
 *   CxA4_Funktion_verfuegbar___Aktiv__12V_EAS (164U)
 *   CxA8_Funktion_verfuegbar___Aktiv__24V_EAS (168U)
 *   CxB0_Funktion_temporaer_in_Rueckfallebene (176U)
 *   CxB2_Funktion_temporaer_in_Rueckfallebene__Notfallfunktion_Umwelteinfluesse__Aktiv (178U)
 *   CxE0_Funktion_nicht_verfuegbar___ausgeschaltet (224U)
 *   CxFF_Signal_ungueltig (255U)
 * QU_SER_STMOM_STMOM_DV_ACT: Enumeration of integer in interval [0...255] with enumerators
 *   Cx20_Schnittstelle_verfuegbar___funktionsbereit_ohne_Zusatzdaempfung (32U)
 *   Cx21_Schnittstelle_aktiv___Zusatzdaempfung_nicht_verfuegbar (33U)
 *   Cx22_Schnittstelle_verfuegbar___funktionsbereit_mit_Zusatzdaempfung (34U)
 *   Cx23_Schnittstelle_aktiv___Zusatzdaempfung_verfuegbar (35U)
 *   Cx60_Service_nicht_verfuegbar___Fehler (96U)
 *   Cx80_Schnittstelle_wird_initialisiert (128U)
 *   CxE0_Service_nicht_verfuegbar___Standby___PMA (224U)
 *   CxE1_Service_nicht_verfuegbar___Standby___EPS_Status (225U)
 *   CxFF_Signal_ungueltig (255U)
 * ST_DIAG_OBD_MUX_IMME: Enumeration of integer in interval [0...63] with enumerators
 *   Cx01_Cal_ID__software_calibration_identification_ (1U)
 *   Cx02_CVN__software_calibration_verification_number_ (2U)
 *   Cx3F_Ungueltig (63U)
 * SYS_STATE_ENUM: Enumeration of integer in interval [0...255] with enumerators
 *   Cx00_DISABLE (0U)
 *   Cx01_OFF (1U)
 *   Cx02_RUN (2U)
 *   Cx03_WI (3U)
 *   Cx04_TRANSITION (4U)
 * TEMP_CPO_HET_MNG: Enumeration of integer in interval [0...255] with enumerators
 *   CxFD_Reserviert (253U)
 *   CxFE_Reserviert (254U)
 *   CxFF_Signal_unbefuellt (255U)
 * UN_PO_EPS: Enumeration of integer in interval [0...3] with enumerators
 *   Cx0_Ritzelschnittstelle (0U)
 *   Cx1_Zahnstangenhubschnittstelle (1U)
 *   Cx3_Signal_ungueltig (3U)
 * UN_TOT_STR_EPS: Enumeration of integer in interval [0...3] with enumerators
 *   Cx0_Ritzelschnittstelle (0U)
 *   Cx1_Zahnstangenhubschnittstelle (1U)
 *   Cx3_Signal_ungueltig (3U)
 *
 * Array Types:
 * ============
 * DIAG_OBD_DATA_Type: Array with 8 element(s) of type UInt6
 *
 * Record Types:
 * =============
 * Edch_EventStatusIpduDataType: Record with elements
 *   IpduData of type DIAG_OBD_DATA_Type
 * RT_SG_AVL_FORC_GRD: Record with elements
 *   ALIV_AVL_FORC_GRD of type ALIV_COU_4
 *   AVL_FORC_GRD of type AVL_FORC_GRD
 *   AVL_FORC_GRD_0x0C_0x04 of type CD_0x04
 *   AVL_PWR_EL_EPS_COOD of type AVL_PWR_EL
 *   CRC_AVL_FORC_GRD of type CRC8
 *   QU_AVL_FORC_GRD of type QU_AVL_FORC_GRD
 * RT_SG_AVL_PO_EPS: Record with elements
 *   ALIV_AVL_PO_EPS of type ALIV_COU_4
 *   AVL_PO_EPS of type AVL_PINA_EPS
 *   CRC_AVL_PO_EPS of type CRC8
 *   IDX_TORQ_SEN of type IDX_TORQ_SEN
 *   AVL_PO_IDX_EPS of type AVL_PINA_IDX_ICM
 *   OFFS_GRD_MID_EPS of type OFFS_GRD_MID_EPS
 *   QU_AVL_PO_EPS of type QU_AVL_PINA_EPS
 *   UN_PO_EPS of type UN_PO_EPS
 * RT_SG_AVL_STMOM_DV_ACT: Record with elements
 *   ALIV_AVL_STMOM_DV_ACT of type ALIV_COU_4
 *   AVL_STMOM_DV_ACT of type STMOM_QTA_DV
 *   CRC_AVL_STMOM_DV_ACT of type CRC8
 *   QU_AVL_STMOM_DV_ACT of type QU_AVL_STMOM_DV_ACT
 * RT_SG_ST_EST: Record with elements
 *   ALIV_ST_EST_FTAX of type ALIV_COU_4
 *   CRC_ST_EST_FTAX of type CRC8
 *   QU_FN_EST of type QU_FN_EST
 *   QU_SER_STMOM_DV_ACT of type QU_SER_STMOM_STMOM_DV_ACT
 *   QU_FN_VIB_EPS of type New_Coding_50
 * RT_SG_SU_EPS: Record with elements
 *   TOT_STR_EPS of type TOT_STR_EPS
 *   UN_TOT_STR_EPS of type UN_TOT_STR_EPS
 *   ALIV_SU_EPS of type New_Coding_51
 *   CRC_SU_EPS of type New_Coding_52
 * SG_ANFRAGE_DSC_Modul: Record with elements
 *   ID2_0x08_Mx01_DSC_Modul of type CD_0x08
 *   ID_FN_INQY_DSC_Modul of type ID_FN_INQY
 * SG_ANFRAGE_SAS: Record with elements
 *   ID_FN_INQY_SAS of type ID_FN_INQY
 *   ID2_0x08_Mx01_SAS of type CD_0x08
 * SG_ANFRAGE_ZGW: Record with elements
 *   ID_FN_INQY_ZGW of type ID_FN_INQY
 *   ID2_0x08_Mx01_ZGW of type CD_0x08
 * SG_DISP_CC_EPS: Record with elements
 *   TRANF_CC_EPS of type New_Coding_45
 *   NO_CC_EPS of type New_Coding_43
 *   ST_CC_EPS of type New_Coding_46
 *   ST_IDC_CC_EPS of type New_Coding_44
 *   CRC_DISP_CC_EPS of type New_Coding_40
 *   CHL_DISP_CC_EPS of type New_Coding_41
 *   ALIV_DISP_CC_EPS of type New_Coding_42
 * SG_DT_EST: Record with elements
 *   CRC_DT_EST of type New_Coding_47
 *   DT_EST_0x38_0x20 of type CD_0x20
 *   DT_EST_0x2C_0x04 of type CD_0x04
 *   ALIV_DT_EST of type New_Coding_48
 *   AVL_I_ACT_EST of type New_Coding_49
 *   DT_EST_0x78_0x08 of type CD_0x08
 *   DT_EST_0x0C_0x20 of type CD_0x20
 *   DT_EST_0x58_0x20 of type CD_0x20
 *
 *********************************************************************************************************************/


/**********************************************************************************************************************
 *
 * Defined Constants
 *
 **********************************************************************************************************************
 *
 * Primitive Type Constants:
 * =========================
 * Boolean: D_FALSE_CNT_LGC = FALSE
 * Float: D_VECUMIN_VOLTS_F32 = 5.0F
 * Float: D_ZERO_ULS_F32 = 0.0F
 * UInt16: D_RACKTOVEHCNTRINVALID_CNT_U16 = 4095U
 * UInt8: D_ONE_CNT_U8 = 1U
 *
 *********************************************************************************************************************/


#define RTE_START_SEC_AP_SRLCOMOUTPUT_APPL_CODE
#include "MemMap.h" /* PRQA S 5087 */

/**********************************************************************************************************************
 *
 * Runnable Entity Name: SrlComOutput_Init1
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on entering of Mode <RUN> of ModeDeclarationGroupPrototype <currentMode> of PortPrototype <EcuM_CurrentMode>
 *
 **********************************************************************************************************************
 *
 * Mode Interfaces:
 * ================
 *   Rte_ModeType_EcuM_Mode Rte_Mode_EcuM_CurrentMode_currentMode(void)
 *   Modes of Rte_ModeType_EcuM_Mode:
 *   - RTE_MODE_EcuM_Mode_POST_RUN
 *   - RTE_MODE_EcuM_Mode_RUN
 *   - RTE_MODE_EcuM_Mode_SHUTDOWN
 *   - RTE_MODE_EcuM_Mode_SLEEP
 *   - RTE_MODE_EcuM_Mode_STARTUP
 *   - RTE_MODE_EcuM_Mode_WAKE_SLEEP
 *   - RTE_TRANSITION_EcuM_Mode
 *   Rte_ModeType_StaMd_Mode Rte_Mode_SystemState_Mode(void)
 *   Modes of Rte_ModeType_StaMd_Mode:
 *   - RTE_MODE_StaMd_Mode_DISABLE
 *   - RTE_MODE_StaMd_Mode_OFF
 *   - RTE_MODE_StaMd_Mode_OPERATE
 *   - RTE_MODE_StaMd_Mode_WARMINIT
 *   - RTE_TRANSITION_StaMd_Mode
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_EpsComMStRqst_RequestComMode(ComM_ModeType ComMode)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_ComM_UserRequest_COMM_E_MODE_LIMITATION, RTE_E_ComM_UserRequest_E_NOT_OK
 *
 *********************************************************************************************************************/

FUNC(void, RTE_AP_SRLCOMOUTPUT_APPL_CODE) SrlComOutput_Init1(void)
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: SrlComOutput_Init1
 *********************************************************************************************************************/

	(void)Rte_Call_EpsComMStRqst_RequestComMode(COMM_FULL_COMMUNICATION);

	CDD_FirstActvNTC_Cnt_G_u16 = 0U;

/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: SrlComOutput_Per1
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on TimingEvent every 10ms
 *
 **********************************************************************************************************************
 *
 * Input Interfaces:
 * =================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Read_CtrlTempFinal_DegC_f32(Float *data)
 *   Std_ReturnType Rte_Read_ST_DIAG_OBD_ALIVE(UInt4 *data)
 *   Std_ReturnType Rte_Read_ST_DIAG_OBD_DATA(Edch_EventStatusIpduDataType *data)
 *   Std_ReturnType Rte_Read_ST_DIAG_OBD_MUX_IMME(UInt6 *data)
 *   Std_ReturnType Rte_Read_ST_DIAG_OBD_MUX_MAX(UInt6 *data)
 *   Std_ReturnType Rte_Read_SrlComAVLPOEPS_AVL_PO_EPS(RT_SG_AVL_PO_EPS *data)
 *   Std_ReturnType Rte_Read_SrlComAVLSTMOM_AVL_FORC_GRD(RT_SG_AVL_FORC_GRD *data)
 *   Std_ReturnType Rte_Read_SrlComAVLSTMOM_AVL_STMOM_DV_ACT(RT_SG_AVL_STMOM_DV_ACT *data)
 *   Std_ReturnType Rte_Read_SrlComDISPCCEPS_DISP_CC_EPS(SG_DISP_CC_EPS *data)
 *   Std_ReturnType Rte_Read_SrlComDTEST_DT_EST(SG_DT_EST *data)
 *   Std_ReturnType Rte_Read_SrlComSTEST_ST_EST(RT_SG_ST_EST *data)
 *   Std_ReturnType Rte_Read_SrlComSUEPS_SU_EPS(RT_SG_SU_EPS *data)
 *
 *   E2E Protection Wrapper API:
 *   ---------------------------
 *
 * Output Interfaces:
 * ==================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Write_AVL_PO_EPS_AVL_PO_EPS(const RT_SG_AVL_PO_EPS *data)
 *   Std_ReturnType Rte_Write_AVL_PO_EPS_TRGG_ENGTORQ_EPS(New_Coding_39 data)
 *   Std_ReturnType Rte_Write_AVL_STMOM_AVL_FORC_GRD(const RT_SG_AVL_FORC_GRD *data)
 *   Std_ReturnType Rte_Write_AVL_STMOM_AVL_STMOM_DV_ACT(const RT_SG_AVL_STMOM_DV_ACT *data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_ALIV_ST_DIAG_OBD_3_DRDY(ALIV_4_BIT_Unsigned_Integer data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_1(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_2(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_3(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_4(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_5(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_6(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_7(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_8(DIAG_ST_OBD data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_ST_DIAG_OBD_3_DRDY_IMME_MUX(ST_DIAG_OBD_MUX_IMME data)
 *   Std_ReturnType Rte_Write_DIAG_ST_OBD_3_DRDY_ST_DIAG_OBD_3_DRDY_MAX_MUX(ST_DIAG_OBD_MUX_MAX data)
 *   Std_ReturnType Rte_Write_DISP_CC_EPS_DISP_CC_EPS(const SG_DISP_CC_EPS *data)
 *   Std_ReturnType Rte_Write_DT_EST_DT_EST(const SG_DT_EST *data)
 *   Std_ReturnType Rte_Write_ID_TEMP_CPO_HET_MNG_EPS_ID_TEMP_CPO_HET_MNG_EPS(ID_TEMP_CPO_HET_MNG data)
 *   Std_ReturnType Rte_Write_ST_EST_ST_EST(const RT_SG_ST_EST *data)
 *   Std_ReturnType Rte_Write_SU_EPS_SU_EPS(const RT_SG_SU_EPS *data)
 *   Std_ReturnType Rte_Write_TEMP_CPO_HET_MNG_EPS_TEMP_CPO_HET_MNG_EPS(TEMP_CPO_HET_MNG data)
 *
 *   E2E Protection Wrapper API:
 *   ---------------------------
 *   uint32 E2EPW_Write_AVL_PO_EPS_AVL_PO_EPS(RT_SG_AVL_PO_EPS *data)
 *   uint32 E2EPW_Write_AVL_STMOM_AVL_FORC_GRD(RT_SG_AVL_FORC_GRD *data)
 *   uint32 E2EPW_Write_AVL_STMOM_AVL_STMOM_DV_ACT(RT_SG_AVL_STMOM_DV_ACT *data)
 *   uint32 E2EPW_Write_DISP_CC_EPS_DISP_CC_EPS(SG_DISP_CC_EPS *data)
 *   uint32 E2EPW_Write_DT_EST_DT_EST(SG_DT_EST *data)
 *   uint32 E2EPW_Write_ST_EST_ST_EST(RT_SG_ST_EST *data)
 *
 *   Implicit S/R API:
 *   -----------------
 *   void Rte_IWrite_SrlComOutput_Per1_AVLFORCGRDTxConf_Cnt_lgc(Boolean data)
 *   Boolean *Rte_IWriteRef_SrlComOutput_Per1_AVLFORCGRDTxConf_Cnt_lgc(void)
 *   void Rte_IWrite_SrlComOutput_Per1_AVLSTMOMTxConf_Cnt_lgc(Boolean data)
 *   Boolean *Rte_IWriteRef_SrlComOutput_Per1_AVLSTMOMTxConf_Cnt_lgc(void)
 *
 * Mode Interfaces:
 * ================
 *   Rte_ModeType_EcuM_Mode Rte_Mode_EcuM_CurrentMode_currentMode(void)
 *   Modes of Rte_ModeType_EcuM_Mode:
 *   - RTE_MODE_EcuM_Mode_POST_RUN
 *   - RTE_MODE_EcuM_Mode_RUN
 *   - RTE_MODE_EcuM_Mode_SHUTDOWN
 *   - RTE_MODE_EcuM_Mode_SLEEP
 *   - RTE_MODE_EcuM_Mode_STARTUP
 *   - RTE_MODE_EcuM_Mode_WAKE_SLEEP
 *   - RTE_TRANSITION_EcuM_Mode
 *   Rte_ModeType_StaMd_Mode Rte_Mode_SystemState_Mode(void)
 *   Modes of Rte_ModeType_StaMd_Mode:
 *   - RTE_MODE_StaMd_Mode_DISABLE
 *   - RTE_MODE_StaMd_Mode_OFF
 *   - RTE_MODE_StaMd_Mode_OPERATE
 *   - RTE_MODE_StaMd_Mode_WARMINIT
 *   - RTE_TRANSITION_StaMd_Mode
 *
 * Client/Server Interfaces:
 * =========================
 *   Server Invocation:
 *   ------------------
 *   Std_ReturnType Rte_Call_NxtrDiagMgr_GetNTCFailed(NTCNumber NTC_Cnt_T_enum, Boolean *NTCFailed_Ptr_T_lgc)
 *     Synchronous Server Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_NxtrDiagMgr_E_NOT_OK
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_EPSIndicatorStatus_GetIndicatorStatus(Dem_IndicatorStatusType *IndicatorStatus)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_IndicatorStatus_E_NOT_OK
 *
 *********************************************************************************************************************/

FUNC(void, RTE_AP_SRLCOMOUTPUT_APPL_CODE) SrlComOutput_Per1(void)
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: SrlComOutput_Per1
 *********************************************************************************************************************/
	VAR(RT_SG_AVL_FORC_GRD, AUTOMATIC) AvlForcGrd_T_Str;
	VAR(RT_SG_AVL_STMOM_DV_ACT, AUTOMATIC) AvlStmomDvAct_T_Str;

	VAR(RT_SG_AVL_PO_EPS, AUTOMATIC) AvlPoEpsData_T_Str;
	VAR(uint16, AUTOMATIC) TrggEngTorqEps_Cnt_T_u16;
	
	VAR(ID_TEMP_CPO_HET_MNG, AUTOMATIC) IDTempCpoHetMng_T_enum;
	VAR(TEMP_CPO_HET_MNG, AUTOMATIC) TempCpoHetMng_T_enum;
	VAR(float32, AUTOMATIC) CtrlTemp_DegC_T_f32;
	VAR(boolean, AUTOMATIC) ThermFlt_Cnt_T_lgc;

	VAR(uint8, AUTOMATIC) DiagOBDAlive_Cnt_T_u8;
	VAR(Edch_EventStatusIpduDataType, AUTOMATIC) DiagOBDData_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) DiagOBDMuxImme_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) DiagOBDMuxMax_Cnt_T_u8;

	VAR(SG_DT_EST, AUTOMATIC) DtEst_T_Str;
	VAR(RT_SG_SU_EPS, AUTOMATIC) SuEps_T_Str;
	VAR(SG_DISP_CC_EPS, AUTOMATIC) DispCCEps_T_Str;
  VAR(RT_SG_ST_EST, AUTOMATIC) StEst_T_Str;

  /* Configurable Start of Runnable Checkpoint */
	(void)Rte_Call_SrlComOutput_Per1_CP0_CheckpointReached();
    
	(void)T1_AppHandler();
  
  if(FrCycleSwitchOddEven_Cnt_G_u08 == 0)
  {
	  /* Read Tx signal data from ASIL_D application SrlComOutput2 */
	  
	  (void)Rte_Read_SrlComAVLPOEPS_AVL_PO_EPS(&AvlPoEpsData_T_Str);
    (void)Rte_Write_AVL_PO_EPS_AVL_PO_EPS(&AvlPoEpsData_T_Str);
	  (void)Rte_Read_SrlComAVLSTMOM_AVL_FORC_GRD(&AvlForcGrd_T_Str);
	  (void)Rte_Read_SrlComAVLSTMOM_AVL_STMOM_DV_ACT(&AvlStmomDvAct_T_Str);
    
    /* UPDATE ASIL_D SIGNALS */
	  if (AVLFORCGRDTxConf_Cnt_M_lgc == FALSE)
	  {
	  	AvlForcGrd_T_Str.QU_AVL_FORC_GRD = D_INITIALIZATION_CNT_U16;
	  }
    
	  if (AVLSTMOMTxConf_Cnt_M_lgc == FALSE)
	  {
	  	AvlStmomDvAct_T_Str.QU_AVL_STMOM_DV_ACT = D_INITIALIZATION_CNT_U16;
	  }
    
    (void)Rte_Write_AVL_STMOM_AVL_FORC_GRD(&AvlForcGrd_T_Str);
	  (void)Rte_Write_AVL_STMOM_AVL_STMOM_DV_ACT(&AvlStmomDvAct_T_Str);
    
    if(CDD_TxDispSendMsg_Cnt_G_lgc == TRUE)
    {
      (void)Rte_Read_SrlComDISPCCEPS_DISP_CC_EPS(&DispCCEps_T_Str);
      (void)Rte_Write_Ap_SrlComOutput_DISP_CC_EPS_DISP_CC_EPS(&DispCCEps_T_Str);
      /* Reset to False since its transmitted above */
      CDD_TxDispSendMsg_Cnt_G_lgc = FALSE;
    }  
	  
    (void)Rte_Read_SrlComSUEPS_SU_EPS(&SuEps_T_Str);
    (void)Rte_Read_SrlComSTEST_ST_EST(&StEst_T_Str);
    
	  /* Update TEMP_CPO_HET_MNG data */
	  (void)Rte_Call_NxtrDiagMgr_GetNTCFailed(NTC_Num_Thermistor, &ThermFlt_Cnt_T_lgc);
	  (void)Rte_Read_CtrlTempFinal_DegC_f32(&CtrlTemp_DegC_T_f32);
    
	  if(ThermFlt_Cnt_T_lgc == TRUE)
	  {
	  	/* Fault Active */
	  	IDTempCpoHetMng_T_enum = CxF_Signal_unbefuellt;
	  	TempCpoHetMng_T_enum = CxFF_Signal_unbefuellt;
	  }
	  else
	  {
	  	/* No Fault Active */
	  	IDTempCpoHetMng_T_enum = Cx1_EPS_Motortemperatur;
    
	  	/* Temp range is -48 to 204 */
	  	CtrlTemp_DegC_T_f32 = Limit_m(CtrlTemp_DegC_T_f32, D_TEMPCPO_LOWLMT_CNT_F32, D_TEMPCPO_HIGHLMT_CNT_F32);
	  	TempCpoHetMng_T_enum = (TEMP_CPO_HET_MNG)FPM_FloatToFixed_m((CtrlTemp_DegC_T_f32 + D_TEMPCPO_TEMPOFFSET_CNT_F32), u16p0_T);
	  }
    
	  /* Update signal */
	  (void)Rte_Write_ID_TEMP_CPO_HET_MNG_EPS_ID_TEMP_CPO_HET_MNG_EPS(IDTempCpoHetMng_T_enum);
	  (void)Rte_Write_TEMP_CPO_HET_MNG_EPS_TEMP_CPO_HET_MNG_EPS(TempCpoHetMng_T_enum);
    
	  

    
	  /* Update TRGG_ENGTORQ_EPS */
	  TrggEngTorqEps_Cnt_T_u16 = 0xFFFu;
    

	  (void)Rte_Write_AVL_PO_EPS_TRGG_ENGTORQ_EPS(TrggEngTorqEps_Cnt_T_u16);

    
	  /* Transmit SU_EPS */
	  if (CDD_TxSUEPSSendMsg_Cnt_G_lgc == TRUE)
	  {
	  	/* The Send message flag is to prevent the message from being sent every 40ms. Fibex is configured for event and
	  	 * periodic rates */
	  (void)Rte_Write_SU_EPS_SU_EPS(&SuEps_T_Str);
	  	CDD_TxSUEPSSendMsg_Cnt_G_lgc = FALSE;
	  }
     /* Transmit ST_EST */
     if(CDD_TxSTEPSSendMSg_Cnt_G_lgc == TRUE)
     {
        (void)Rte_Write_ST_EST_ST_EST(&StEst_T_Str);
        CDD_TxSTEPSSendMSg_Cnt_G_lgc = FALSE;
     }
    
	  (void)Rte_IWrite_SrlComOutput_Per1_AVLFORCGRDTxConf_Cnt_lgc(AVLFORCGRDTxConf_Cnt_M_lgc);
	  (void)Rte_IWrite_SrlComOutput_Per1_AVLSTMOMTxConf_Cnt_lgc(AVLSTMOMTxConf_Cnt_M_lgc);
	  
  }  
  else
  {
    (void)Rte_Read_SrlComDTEST_DT_EST(&DtEst_T_Str);
	  (void)Rte_Write_DT_EST_DT_EST(&DtEst_T_Str);
    
    
	  (void)Rte_Read_ST_DIAG_OBD_ALIVE(&DiagOBDAlive_Cnt_T_u8);
	  (void)Rte_Read_ST_DIAG_OBD_DATA(&DiagOBDData_Cnt_T_u8);
	  (void)Rte_Read_ST_DIAG_OBD_MUX_IMME(&DiagOBDMuxImme_Cnt_T_u8);
	  (void)Rte_Read_ST_DIAG_OBD_MUX_MAX(&DiagOBDMuxMax_Cnt_T_u8);
    
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_ALIV_ST_DIAG_OBD_3_DRDY(DiagOBDAlive_Cnt_T_u8);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_1(DiagOBDData_Cnt_T_u8.IpduData[0]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_2(DiagOBDData_Cnt_T_u8.IpduData[1]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_3(DiagOBDData_Cnt_T_u8.IpduData[2]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_4(DiagOBDData_Cnt_T_u8.IpduData[3]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_5(DiagOBDData_Cnt_T_u8.IpduData[4]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_6(DiagOBDData_Cnt_T_u8.IpduData[5]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_7(DiagOBDData_Cnt_T_u8.IpduData[6]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_DIAG_ST_OBD_3_DRDY_8(DiagOBDData_Cnt_T_u8.IpduData[7]);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_ST_DIAG_OBD_3_DRDY_IMME_MUX(DiagOBDMuxImme_Cnt_T_u8);
	  (void)Rte_Write_DIAG_ST_OBD_3_DRDY_ST_DIAG_OBD_3_DRDY_MAX_MUX(DiagOBDMuxMax_Cnt_T_u8);
    
  }  
  
	/* Configurable End of Runnable Checkpoint */
	Rte_Call_SrlComOutput_Per1_CP1_CheckpointReached();
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: SrlComOutput_Per2
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on TimingEvent every 5ms
 *
 **********************************************************************************************************************
 *
 * Input Interfaces:
 * =================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Read_CtrlTempFinal_DegC_f32(Float *data)
 *   Std_ReturnType Rte_Read_CuTempEst_DegC_f32(Float *data)
 *   Std_ReturnType Rte_Read_EpsOpTrq_MtrNm_f32(Float *data)
 *   Std_ReturnType Rte_Read_EstBattCurr_Amp_f32(Float *data)
 *   Std_ReturnType Rte_Read_FinHwPos_HwDeg_f32(Float *data)
 *   Std_ReturnType Rte_Read_HwTrq_HwNm_f32(Float *data)
 *   Std_ReturnType Rte_Read_MagTempEst_DegC_f32(Float *data)
 *   Std_ReturnType Rte_Read_MtrCurrQax_Amp_f32(Float *data)
 *   Std_ReturnType Rte_Read_MtrTrqCmd_MtrNm_f32(Float *data)
 *   Std_ReturnType Rte_Read_MtrVel_MtrRadpS_f32(Float *data)
 *   Std_ReturnType Rte_Read_T1ADC_Volt_f32(Float *data)
 *   Std_ReturnType Rte_Read_T2ADC_Volt_f32(Float *data)
 *   Std_ReturnType Rte_Read_ThermLimitPerc_Uls_f32(Float *data)
 *   Std_ReturnType Rte_Read_TxDebugMsgEn_Cnt_lgc(Boolean *data)
 *   Std_ReturnType Rte_Read_Vecu_Volt_f32(Float *data)
 *
 *   E2E Protection Wrapper API:
 *   ---------------------------
 *
 * Output Interfaces:
 * ==================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_Batt(BATT_VOLTS data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_CtrlTemp(CONT_TEMP_DEG data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_DiffTrq(DIFF_TRQ_NM data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_EstBattCurr(EST_BATT_AMPS data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_EstCuTemp(EST_CUTEMP_DEG data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_EstMtrTemp(EST_MOTTEMP_DEG data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_MtrCurr(New_Coding_3 data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_MtrTrqCmd(MTRTRQCMD_NM data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_MtrTrqCmdLmtd(MTRTRQLMTD_NM data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_MtrVel(MOT_VEL_RADPSEC data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_NTCNumber(New_Coding_28 data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_Res_TBD(New_Coding_15 data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_SWA(SWA_DEG data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_SystemState(SYS_STATE_ENUM data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_ThrmlLimitPerc(THRML_LIMIT_PERC data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_Trq1(TORQUE1_VOLTS data)
 *   Std_ReturnType Rte_Write_FR_DBG_EPS_Trq2(TORQUE2_VOLTS data)
 *
 *   E2E Protection Wrapper API:
 *   ---------------------------
 *
 * Mode Interfaces:
 * ================
 *   Rte_ModeType_EcuM_Mode Rte_Mode_EcuM_CurrentMode_currentMode(void)
 *   Modes of Rte_ModeType_EcuM_Mode:
 *   - RTE_MODE_EcuM_Mode_POST_RUN
 *   - RTE_MODE_EcuM_Mode_RUN
 *   - RTE_MODE_EcuM_Mode_SHUTDOWN
 *   - RTE_MODE_EcuM_Mode_SLEEP
 *   - RTE_MODE_EcuM_Mode_STARTUP
 *   - RTE_MODE_EcuM_Mode_WAKE_SLEEP
 *   - RTE_TRANSITION_EcuM_Mode
 *   Rte_ModeType_StaMd_Mode Rte_Mode_SystemState_Mode(void)
 *   Modes of Rte_ModeType_StaMd_Mode:
 *   - RTE_MODE_StaMd_Mode_DISABLE
 *   - RTE_MODE_StaMd_Mode_OFF
 *   - RTE_MODE_StaMd_Mode_OPERATE
 *   - RTE_MODE_StaMd_Mode_WARMINIT
 *   - RTE_TRANSITION_StaMd_Mode
 *
 *********************************************************************************************************************/

FUNC(void, RTE_AP_SRLCOMOUTPUT_APPL_CODE) SrlComOutput_Per2(void)
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: SrlComOutput_Per2
 *********************************************************************************************************************/
	VAR(float32, AUTOMATIC) Vecu_Volts_T_f32;
	VAR(float32, AUTOMATIC) HwTrq_HwNm_T_f32;
	VAR(float32, AUTOMATIC) CtrlTempFinal_DegC_T_f32;
	VAR(float32, AUTOMATIC) EstBattCurr_Amp_T_f32;
	VAR(float32, AUTOMATIC) CuTempEst_DegC_T_f32;
	VAR(float32, AUTOMATIC) MagTempEst_DegC_T_f32;
	VAR(float32, AUTOMATIC) EpsOpTrq_MtrNm_T_f32;
	VAR(float32, AUTOMATIC) MtrTrqCmd_MtrNm_T_f32;
	VAR(float32, AUTOMATIC) MtrVel_MtrRadpS_T_f32;
    VAR(float32, AUTOMATIC) FinHwPos_HwDeg_T_f32;
	VAR(Rte_ModeType_StaMd_Mode, AUTOMATIC) SystemState_Cnt_T_enum;
	VAR(uint8, AUTOMATIC) NxtrSystemState_Cnt_T_u08;
	VAR(float32, AUTOMATIC) T1_Volts_T_f32;
	VAR(float32, AUTOMATIC) T2_Volts_T_f32;
	VAR(float32, AUTOMATIC) MtrCurrQax_Amp_T_f32;
	VAR(float32, AUTOMATIC) ThrmlLimitPerc_Uls_T_f32;

	VAR(uint16, AUTOMATIC) Batt_Cnt_T_u16;
	VAR(uint8, AUTOMATIC) CtrlTemp_Cnt_T_u8;
	VAR(sint16, AUTOMATIC) DiffTrq_Cnt_T_s16;
	VAR(sint16, AUTOMATIC) EstBattCurr_Cnt_T_s16;
	VAR(uint8, AUTOMATIC) EstCuTemp_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) EstMtrTemp_Cnt_T_u8;
	VAR(sint16, AUTOMATIC) MtrTrqCmd_Cnt_T_s16;
	VAR(sint16, AUTOMATIC) MtrTrqCmdLmtd_Cnt_T_s16;
	VAR(sint16, AUTOMATIC) MtrVel_Cnt_T_s16;
	VAR(sint16, AUTOMATIC) SWA_Cnt_T_s16;
	VAR(uint16, AUTOMATIC) Trq1_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) Trq2_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) MtrCurrQax_Amp_T_u16;
	VAR(uint8, AUTOMATIC) ThrmlLimitPerc_Cnt_T_u8;

	VAR(boolean, AUTOMATIC) TxDebugMsg_Cnt_T_lgc;

	/* Read VehConfig data */
	/* Configurable Start of Runnable Checkpoint */
	Rte_Call_SrlComOutput_Per2_CP0_CheckpointReached();

 	(void)Rte_Read_TxDebugMsgEn_Cnt_lgc(&TxDebugMsg_Cnt_T_lgc);
	
	if (TRUE == TxDebugMsg_Cnt_T_lgc)
	{
		if (TRUE == AVLPOEPSTxConf_Cnt_M_lgc)
		{   /* Start Tx group after ensuring that CC is online */
			Com_IpduGroupStart(PduGrp_EPS__A_FlexRay_TxDebug, FALSE);
		}
	}
	else
	{
		Com_IpduGroupStop(PduGrp_EPS__A_FlexRay_TxDebug);
	}

	/* Update FR_DBG_EPS Data */
	(void)Rte_Read_MtrCurrQax_Amp_f32(&MtrCurrQax_Amp_T_f32);
	(void)Rte_Read_Vecu_Volt_f32(&Vecu_Volts_T_f32);
	(void)Rte_Read_CtrlTempFinal_DegC_f32(&CtrlTempFinal_DegC_T_f32);
	(void)Rte_Read_HwTrq_HwNm_f32(&HwTrq_HwNm_T_f32);
	(void)Rte_Read_EstBattCurr_Amp_f32(&EstBattCurr_Amp_T_f32);
	(void)Rte_Read_CuTempEst_DegC_f32(&CuTempEst_DegC_T_f32);
	(void)Rte_Read_MagTempEst_DegC_f32(&MagTempEst_DegC_T_f32);
	(void)Rte_Read_EpsOpTrq_MtrNm_f32(&EpsOpTrq_MtrNm_T_f32);
	(void)Rte_Read_MtrTrqCmd_MtrNm_f32(&MtrTrqCmd_MtrNm_T_f32);
	(void)Rte_Read_MtrVel_MtrRadpS_f32(&MtrVel_MtrRadpS_T_f32);
	(void)Rte_Read_FinHwPos_HwDeg_f32(&FinHwPos_HwDeg_T_f32);
	SystemState_Cnt_T_enum = Rte_Mode_SystemState_Mode();
	(void)Rte_Read_T1ADC_Volt_f32(&T1_Volts_T_f32);
	(void)Rte_Read_T2ADC_Volt_f32(&T2_Volts_T_f32);
	(void)Rte_Read_ThermLimitPerc_Uls_f32(&ThrmlLimitPerc_Uls_T_f32);

	MtrCurrQax_Amp_T_u16 = FPM_FloatToFixed_m(MtrCurrQax_Amp_T_f32, u16p0_T);
	Batt_Cnt_T_u16 = FPM_FloatToFixed_m(Vecu_Volts_T_f32, u10p6_T);
	CtrlTemp_Cnt_T_u8 = (uint8)FPM_FloatToFixed_m((CtrlTempFinal_DegC_T_f32 + D_TEMPOFFSET_DEGC_F32), u16p0_T);
	DiffTrq_Cnt_T_s16 = FPM_FloatToFixed_m(HwTrq_HwNm_T_f32, s7p8_T);
	EstBattCurr_Cnt_T_s16 = FPM_FloatToFixed_m(EstBattCurr_Amp_T_f32, s12p3_T);
	EstCuTemp_Cnt_T_u8 = (uint8)FPM_FloatToFixed_m((CuTempEst_DegC_T_f32 + D_TEMPOFFSET_DEGC_F32), u16p0_T);
	EstMtrTemp_Cnt_T_u8 = (uint8)FPM_FloatToFixed_m((MagTempEst_DegC_T_f32 + D_TEMPOFFSET_DEGC_F32), u16p0_T);
	MtrTrqCmd_Cnt_T_s16 = FPM_FloatToFixed_m(EpsOpTrq_MtrNm_T_f32, s4p11_T);
	MtrTrqCmdLmtd_Cnt_T_s16 = FPM_FloatToFixed_m(MtrTrqCmd_MtrNm_T_f32, s4p11_T);
	MtrVel_Cnt_T_s16 = FPM_FloatToFixed_m(MtrVel_MtrRadpS_T_f32 , s11p4_T);
	SWA_Cnt_T_s16 = FPM_FloatToFixed_m(FinHwPos_HwDeg_T_f32, s11p4_T);
	Trq1_Cnt_T_u16 = FPM_FloatToFixed_m(T1_Volts_T_f32, u8p8_T);
	Trq2_Cnt_T_u16 = FPM_FloatToFixed_m(T2_Volts_T_f32, u8p8_T);
	ThrmlLimitPerc_Cnt_T_u8 = Limit_m((uint8)(FPM_FloatToFixed_m(ThrmlLimitPerc_Uls_T_f32, u9p7_T)), D_ZERO_CNT_U8, D_FRDBG_THRMLLIMPERC_CNT_U8);

	/* Write information to debug frame */
	(void)Rte_Write_FR_DBG_EPS_MtrCurr(MtrCurrQax_Amp_T_u16);
	(void)Rte_Write_FR_DBG_EPS_Batt(Batt_Cnt_T_u16);
	(void)Rte_Write_FR_DBG_EPS_CtrlTemp(CtrlTemp_Cnt_T_u8);
	(void)Rte_Write_FR_DBG_EPS_DiffTrq(DiffTrq_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_EstBattCurr(EstBattCurr_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_EstCuTemp(EstCuTemp_Cnt_T_u8);
	(void)Rte_Write_FR_DBG_EPS_EstMtrTemp(EstMtrTemp_Cnt_T_u8);
	(void)Rte_Write_FR_DBG_EPS_MtrTrqCmd(MtrTrqCmd_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_MtrTrqCmdLmtd(MtrTrqCmdLmtd_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_MtrVel(MtrVel_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_NTCNumber((New_Coding_28)CDD_FirstActvNTC_Cnt_G_u16);
	(void)Rte_Write_FR_DBG_EPS_Res_TBD((New_Coding_15)0xFFFFU);	/* Set to all ones */
	(void)Rte_Write_FR_DBG_EPS_SWA(SWA_Cnt_T_s16);
	(void)Rte_Write_FR_DBG_EPS_Trq1(Trq1_Cnt_T_u16);
	(void)Rte_Write_FR_DBG_EPS_Trq2(Trq2_Cnt_T_u16);
	(void)Rte_Write_FR_DBG_EPS_ThrmlLimitPerc((THRML_LIMIT_PERC)ThrmlLimitPerc_Cnt_T_u8);
	
	/* Map RTE generated system state enum to Nxtr system state and write to debug frame */ 
	switch(SystemState_Cnt_T_enum)
	{
		case RTE_MODE_StaMd_Mode_DISABLE:	
		NxtrSystemState_Cnt_T_u08 = D_DISABLE_CNT_U08;
		break;
				
		case RTE_MODE_StaMd_Mode_WARMINIT:	
		NxtrSystemState_Cnt_T_u08 = D_WARMINIT_CNT_U08;
		break;
				
		case RTE_MODE_StaMd_Mode_OPERATE:	
		NxtrSystemState_Cnt_T_u08 = D_OPERATE_CNT_U08;
		break;
				
		case RTE_MODE_StaMd_Mode_OFF:	
		NxtrSystemState_Cnt_T_u08 = D_OFF_CNT_U08;
		break;
				
		case RTE_TRANSITION_StaMd_Mode:	
		NxtrSystemState_Cnt_T_u08 = D_TRANSITION_CNT_U08;
		break;
		
		default:
		NxtrSystemState_Cnt_T_u08 = D_INVALIDSTATE_CNT_U08;
		break;
	}
	
	(void)Rte_Write_FR_DBG_EPS_SystemState(NxtrSystemState_Cnt_T_u08);
	

	/* Configurable End of Runnable Checkpoint */
	Rte_Call_SrlComOutput_Per2_CP1_CheckpointReached();
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}

/**********************************************************************************************************************
 *
 * Runnable Entity Name: SrlComOutput_TRGD_SVCRequest
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on DataReceivedEvent for DataElementPrototype <SG_ANFRAGE_DSC_Modul> of PortPrototype <SG_ANFRAGE_DSC_Modul>
 *   - triggered on DataReceivedEvent for DataElementPrototype <SG_ANFRAGE_SAS> of PortPrototype <SG_ANFRAGE_SAS>
 *   - triggered on DataReceivedEvent for DataElementPrototype <SG_ANFRAGE_ZGW> of PortPrototype <SG_ANFRAGE_ZGW>
 *
 **********************************************************************************************************************
 *
 * Input Interfaces:
 * =================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Read_SG_ANFRAGE_DSC_Modul_SG_ANFRAGE_DSC_Modul(SG_ANFRAGE_DSC_Modul *data)
 *   Std_ReturnType Rte_Read_SG_ANFRAGE_SAS_SG_ANFRAGE_SAS(SG_ANFRAGE_SAS *data)
 *   Std_ReturnType Rte_Read_SG_ANFRAGE_ZGW_SG_ANFRAGE_ZGW(SG_ANFRAGE_ZGW *data)
 *
 *   E2E Protection Wrapper API:
 *   ---------------------------
 *
 * Mode Interfaces:
 * ================
 *   Rte_ModeType_EcuM_Mode Rte_Mode_EcuM_CurrentMode_currentMode(void)
 *   Modes of Rte_ModeType_EcuM_Mode:
 *   - RTE_MODE_EcuM_Mode_POST_RUN
 *   - RTE_MODE_EcuM_Mode_RUN
 *   - RTE_MODE_EcuM_Mode_SHUTDOWN
 *   - RTE_MODE_EcuM_Mode_SLEEP
 *   - RTE_MODE_EcuM_Mode_STARTUP
 *   - RTE_MODE_EcuM_Mode_WAKE_SLEEP
 *   - RTE_TRANSITION_EcuM_Mode
 *   Rte_ModeType_StaMd_Mode Rte_Mode_SystemState_Mode(void)
 *   Modes of Rte_ModeType_StaMd_Mode:
 *   - RTE_MODE_StaMd_Mode_DISABLE
 *   - RTE_MODE_StaMd_Mode_OFF
 *   - RTE_MODE_StaMd_Mode_OPERATE
 *   - RTE_MODE_StaMd_Mode_WARMINIT
 *   - RTE_TRANSITION_StaMd_Mode
 *
 *********************************************************************************************************************/

FUNC(void, RTE_AP_SRLCOMOUTPUT_APPL_CODE) SrlComOutput_TRGD_SVCRequest(void)
{
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of runnable implementation >>             DO NOT CHANGE THIS COMMENT!
 * Symbol: SrlComOutput_TRGD_SVCRequest
 *********************************************************************************************************************/
	
	VAR(SG_ANFRAGE_DSC_Modul, AUTOMATIC) DSCModuleSVCReq_Cnt_T_str;
	VAR(SG_ANFRAGE_SAS, AUTOMATIC) SASModuleSVCReq_Cnt_T_str;
	VAR(SG_ANFRAGE_ZGW, AUTOMATIC) ZGWModuleSVCReq_Cnt_T_str;
	
	(void)Rte_Read_SG_ANFRAGE_DSC_Modul_SG_ANFRAGE_DSC_Modul(&DSCModuleSVCReq_Cnt_T_str);
 	(void)Rte_Read_SG_ANFRAGE_SAS_SG_ANFRAGE_SAS(&SASModuleSVCReq_Cnt_T_str);
    (void)Rte_Read_SG_ANFRAGE_ZGW_SG_ANFRAGE_ZGW(&ZGWModuleSVCReq_Cnt_T_str);
 
    if ( ((DSCModuleSVCReq_Cnt_T_str.ID2_0x08_Mx01_DSC_Modul == D_IDFNINQY_CNT_B16) &&
         (DSCModuleSVCReq_Cnt_T_str.ID_FN_INQY_DSC_Modul == D_BROADCASTEPSSETUP_CNT_U16))||
         ((SASModuleSVCReq_Cnt_T_str.ID2_0x08_Mx01_SAS == D_IDFNINQY_CNT_B16) &&
         (SASModuleSVCReq_Cnt_T_str.ID_FN_INQY_SAS == D_BROADCASTEPSSETUP_CNT_U16))||
         ((ZGWModuleSVCReq_Cnt_T_str.ID2_0x08_Mx01_ZGW == D_IDFNINQY_CNT_B16) &&
         (ZGWModuleSVCReq_Cnt_T_str.ID_FN_INQY_ZGW == D_BROADCASTEPSSETUP_CNT_U16)) )
    {
		CDD_TxSUEPS_Cnt_G_lgc = TRUE;
    }
    
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of runnable implementation >>               DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
}


#define RTE_STOP_SEC_AP_SRLCOMOUTPUT_APPL_CODE
#include "MemMap.h" /* PRQA S 5087 */


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of function definition area >>            DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
		                                      

/**********************************************************************************************************************
* Call Out Functions
***********************************************************************************************************************/
FUNC(boolean, AP_SRLCOMOUTPUT_CODE) Appl_COMCout_Pdu_AVL_PO_EPS(	VAR(PduIdType, AUTOMATIC) ComTxPduId, 
																	P2VAR(uint8, AUTOMATIC, AUTOMATIC) SduPtr)
{
	if (TRUE == ComTxPduCallout_lgc)
	{
		SuspendAllInterrupts();
		AVLPOEPSTxConf_Cnt_M_lgc = TRUE;
		ResumeAllInterrupts(); 
	}
	return(TRUE);
}


FUNC(boolean, AP_SRLCOMOUTPUT2_CODE) Appl_COMCout_Pdu_AVL_FORC_GRD(	VAR(PduIdType, AUTOMATIC) ComTxPduId,
																	P2VAR(uint8, AUTOMATIC, AUTOMATIC) SduPtr)
{
	if (TRUE == ComTxPduCallout_lgc)
	{
		SuspendAllInterrupts();
		AVLFORCGRDTxConf_Cnt_M_lgc = TRUE;
		ResumeAllInterrupts();
	}
	return(TRUE);
}


FUNC(boolean, AP_SRLCOMOUTPUT2_CODE) Appl_COMCout_Pdu_AVL_STMOM_DV_ACT(	VAR(PduIdType, AUTOMATIC) ComTxPduId,
																		P2VAR(uint8, AUTOMATIC, AUTOMATIC) SduPtr)
{
	if (TRUE == ComTxPduCallout_lgc)
	{
		SuspendAllInterrupts();
		AVLSTMOMTxConf_Cnt_M_lgc = TRUE;
		ResumeAllInterrupts();
	}
	return(TRUE);
}

/*****************************************************************************
  * Name:        SrlComOutput_MainFunction
  * Description: CDD functionality for syncronizing the SrlComOutput processing
  *					tasks with the FlexRay cycle.  This function does not directly
  *					interface with any SrlComOutput data and thus could be moved to
  *					a CDD file.
  *	  
  *					The alarm managed by this task is synchronized to the FlexRay
  *					cycle and has a desired offset from the start of cycle to 
  *					minimize transmit signal latency, yet ensure completion of
  *					transmit data update prior to the transmit deadline.
  *
  *					The alarm can be configured in the Os to activate the first task  
  *					int the transmit process sequence and then a ChainTask() Os API
  *					call can be used to terminate each task and activate the subsequent
  *					task in the calling order.
  * Inputs:      None
  * Outputs:     None
  *
*****************************************************************************/
FUNC(void, AP_SRLCOMOUTPUT2_CODE) SrlComOutput_MainFunction(void)
{
	VAR(uint8, AUTOMATIC) FrCycle;
	VAR(uint16, AUTOMATIC) FrMacroTick;

	/* Fr_GetGlobalTime() returns E_NOT_OK when FlexRay CC is not in the Normal state */
	if(E_OK == Fr_GetGlobalTime(0U, &FrCycle, &FrMacroTick))
	{
		/* The E2E protected messages provided by EPS are transmitted on a 10ms cycle (i.e. every other Cycle, thus the modulo 2)*/
		if((FrCycle % 2U) == 0U)
	  {
      FrCycleSwitchOddEven_Cnt_G_u08 = 0;
    }
    else 
    {
      FrCycleSwitchOddEven_Cnt_G_u08 = 1;
    }      
			/* Activate the required Output update tasks.  In order to provide the maximum amount of time to completed
			 * the output update tasks prior to the transmit deadlines and eliminate the complexity of alarm management,
			 * the tasks are activated immediately.  Signal latency of the signals in the frames can be reduced by
			 * using an alarm activation strategy, however there are no requirements provided to the software design
			 * that specify the maximum signal latency, thus the implied requirement is that the maximum signal latency is
			 * allowed to be the periodic rate of the frame.
			 *
			 * Additionally, the design of the runnables in the tasks activated by this runnable do not require activation
			 * when the FlexRay CC is not in the Normal state and the Start of Cycle ISR is not being generated.
			 */

			(void)ActivateTask(Task_10msA_10);
			(void)ActivateTask(Task_10msA_9);

	}
	else
	{
		/* Activate the tasks at a 10ms rate (every other time through this runnable) to ensure the signal is ready for
		 * transmit in the first cycle that the EPS ECU joins the network to avoid a null frame. At this time there is not a known
		 * notification mechanism or Status provided from the Fr drivers to indicate that the drivers are preparing to join.
		 * If a notification/status existed, then it would only be required to run this periodically while not on the network. */

			(void)ActivateTask(Task_10msA_10);
			(void)ActivateTask(Task_10msA_9);

		/* Toggle offline counter to allow an update of the transmit data on every other execution of this task.
		 * The Bitwise AND with 1 performs a limit function (i.e. limits the state variable to 0 or 1) */

		FrCycleSwitchOddEven_Cnt_G_u08 = (FrCycleSwitchOddEven_Cnt_G_u08 ^ 1u) & 1u;

	}

}
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of function definition area >>              DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << Start of removed code area >>                   DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/


/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           << End of removed code area >>                     DO NOT CHANGE THIS COMMENT!
 *********************************************************************************************************************/
