/* --------{ BMW C Source File }-------- */
/* !LINKSTO EDCH_SDD_0001, 1
 */
/*------------------------------------------------------------------------------
                      MISRA-Deviations
------------------------------------------------------------------------------*/
/*
   Misra-C:2004 Deviation List:

   MISRA-1) Deviated Rule: 17.4 (required)
   Array indexing shall be the only allowed form of pointer arithmetic.

   Reason:
   Size of memory areas referenced from pointer unknown in runtime,
   so that no arrays can be used.
   
   MISRA-2) Deviated Rule: 11.4(required)
   A cast should not be performed between a pointer type and an integral type.

   Reason:
   Type and structure of data pointing to, not known at compile time,
   pointer to constant header of unknown structure used instead

   MISRA-3) Deviated Rule: 16.4 (required)
   The identifiers used in the declaration and definition of a function shall
   be identical.

   Reason:
   Declaration generated by RTE.
   Concerned different arguments from PORT_API_OPTION argument;
   Naming of arguments in generated function declaration is not defined by AUTOSAR

   MISRA-4) Deviated Rule 8.7 (required)
   Definition of objects at block scope

   Reason:
   Objects need to be static to minimize stack usage.
   AUTOSAR compiler abstraction for static variables within functions is not 
   supported by some compilers.

*/

/*==================[inclusions]==============================================*/

#include <Std_Types.h>           /* AUTOSAR standard types */
#include <Edch.h>                /* Module header file */
#include <Edch_Int.h>            /* Internal module header file */
#include <Edch_Version.h>        /* Module configuration */
/* !LINKSTO EDCH_283, 1
 * !LINKSTO EDCH_147, 1
 */
#include <Crc.h>                 /* AUTOSAR Crc library */

/* ----- NXTR PATCH START ----- */
/* Added By: K. Smith (Nxtr)
 * Date Added: 02Jun14
 *
 * Edch_NxtrNvM.h: Added to complete the mapping from source code to WriteBlock calls
 * Ap_DemIf_NxtrAddon.h: Added for index lookup, see patch for more details in
 * function Edch_EventStatusChanged()
 */
#include "Edch_NxtrNvM.h"
#include "Ap_DemIf_NxtrAddon.h"

/* ----- NXTR PATCH END ----- */

/*==================[version check]===========================================*/

/*------------------[AUTOSAR vendor identification check]-------------------*/

#if (!defined EDCH_VENDOR_ID) /* configuration check */
#error EDCH_VENDOR_ID must be defined
#endif

#if (EDCH_VENDOR_ID != 1U) /* vendor check */
#error EDCH_VENDOR_ID has wrong vendor id
#endif

/*------------------[AUTOSAR specification version identification check]----*/

#if (!defined EDCH_AR_MAJOR_VERSION) /* configuration check */
#error EDCH_AR_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (EDCH_AR_MAJOR_VERSION != 3U)
#error EDCH_AR_MAJOR_VERSION wrong (!= 3U)
#endif

#if (!defined EDCH_AR_MINOR_VERSION) /* configuration check */
#error EDCH_AR_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (EDCH_AR_MINOR_VERSION < 1U )
#error EDCH_AR_MINOR_VERSION wrong (< 1U)
#endif

#if (!defined EDCH_AR_PATCH_VERSION) /* configuration check */
#error EDCH_AR_PATCH_VERSION must be defined
#endif

/* patch version check */
#if (EDCH_AR_PATCH_VERSION < 0U )
#error EDCH_AR_PATCH_VERSION wrong (< 0U)
#endif

/*------------------[AUTOSAR module version identification check]-----------*/

#if (!defined EDCH_SW_MAJOR_VERSION) /* configuration check */
#error EDCH_SW_MAJOR_VERSION must be defined
#endif

/* major version check */
#if (EDCH_SW_MAJOR_VERSION != 1U)
#error EDCH_SW_MAJOR_VERSION wrong (!= 1U)
#endif

#if (!defined EDCH_SW_MINOR_VERSION) /* configuration check */
#error EDCH_SW_MINOR_VERSION must be defined
#endif

/* minor version check */
#if (EDCH_SW_MINOR_VERSION < 4U)
#error EDCH_SW_MINOR_VERSION wrong (< 4U)
#endif

#if (!defined EDCH_SW_PATCH_VERSION) /* configuration check */
#error EDCH_SW_PATCH_VERSION must be defined
#endif

/* patch version check */
#if (EDCH_SW_PATCH_VERSION < 1U)
#error EDCH_SW_PATCH_VERSION wrong (< 1U)
#endif

/*==================[macros]==================================================*/

/*==================[type definitions]========================================*/

/*==================[external function declarations]==========================*/

/*==================[internal function declarations]==========================*/

#define EDCH_START_SEC_CODE
#include "MemMap.h"

/* !LINKSTO EDCH_SDD_0023, 1
 */
EDCH_STATIC FUNC( void, EDCH_CODE ) Edch_Init_First( void );

/* !LINKSTO EDCH_SDD_0011, 1
 */
EDCH_STATIC FUNC( void, EDCH_CODE ) Edch_Init_SendData( void );

/* !LINKSTO EDCH_SDD_0012, 1
 */
EDCH_STATIC FUNC( void, EDCH_CODE )
                                 Edch_SendCyclic_PrepareOccurrenceTimer( void );

/* !LINKSTO EDCH_SDD_0013, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_BurstMode( void );

/* !LINKSTO EDCH_SDD_0014, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_moreEventTriggeredMode
                                                  (Edch_EventIdxType diagIdx);

/* !LINKSTO EDCH_SDD_0015, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_EventTriggeredMode
                                               ( Edch_EventIdxType refDiagIdx );

/* !LINKSTO EDCH_SDD_0024, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE)Edch_SendCyclic_CyclicalMode(void);

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_SDD_0016, 1
 */
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCvn_launchSubCodCvn ( void );
#endif

/* !LINKSTO EDCH_SDD_0017, 1
 */
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCvn_launchSubCvn ( void );

EDCH_STATIC FUNC(void, EDCH_APPL_CODE) Edch_CalculateSubCvn_Int ( void );

/* !LINKSTO EDCH_SDD_0019, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_Crc2Pdu
(
  uint32 crc,
  UInt6 imme
);

#if (EDCH_CODINGSW_CNT != 0U)

/* !LINKSTO EDCH_SDD_0020, 1
 */
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCodingCvn_checkStart( void );

/* !LINKSTO EDCH_SDD_0021, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_CalculateCodingCvn_cleanUp
                                         ( Edch_ChecksumValType my_codCvn_val );
#endif

/* !LINKSTO EDCH_SDD_0022, 1
 */
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_RemoveFromEventList
                          ( Edch_EventIdxType diagIdx );

/* !LINKSTO EDCH_350, 1
 */
EDCH_STATIC FUNC(Std_ReturnType, EDCH_CODE) Edch_CheckMuxImmeFeedback ( void );
#define EDCH_STOP_SEC_CODE
#include "MemMap.h"

/*==================[external constants]======================================*/

#define EDCH_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/* !LINKSTO EDCH_002, 1
 */
/**
 * \brief Contains the reporting order
 *        of the configured OBD relevant diagnostics
 *
 */
CONST( Edch_Diagnostics_NumType, EDCH_CONST )
  Edch_Diagnostics_Number[EDCH_DIAGNOSTICS_COUNT] = EDCH_DIAGNOSTICS_NUMBER;

/* !LINKSTO EDCH_SDD_0305, 1
 */
/**
 * \brief Default values for CAL-ID resp. NvM
 */
CONST(Edch_ChecksumValType, EDCH_CONST) Edch_CalIdDefaultVal = 0xFFFFFFFFU;

/* !LINKSTO EDCH_SDD_0306, 1
 */
/**
 * \brief Default values for CVN resp. NvM
 */
CONST(Edch_ChecksumValType, EDCH_CONST) Edch_CvnDefaultVal = 0xFFFFFFFFU;

#if (EDCH_CODINGSW_CNT != 0)
/* !LINKSTO EDCH_SDD_0307, 1
 */
/**
 * \brief Default values for reference coding CVN resp. NvM
 */
CONST(Edch_ChecksumValType, EDCH_CONST) Edch_RefCodCvnDefaultVal = 0xFFFFFFFFU;

/* !LINKSTO EDCH_SDD_0308, 1
 */
/**
 * \brief Default values for sub coding CVN resp. NvM
 */
CONST(Edch_ChecksumValType, EDCH_CONST) Edch_SubCodCvnDefaultVal = 0xFFFFFFFFU;
#endif

/* !LINKSTO EDCH_SDD_0309, 1
 */
/**
 * \brief Default values for sub CVN resp. NvM
 */
CONST(Edch_ChecksumValType, EDCH_CONST)
	Edch_SubCvnDefaultVal[EDCH_CVNTABLE_CNT] = EDCH_SUBCVNDEFAULTVAL;

/* !LINKSTO EDCH_SDD_0318, 1
 */
/**
 * \brief Default value for restoring from NvM
 */
CONST(Edch_OperationCycleStateType, EDCH_CONST)
                        Edch_OperationCycleStateDefaultVal = EDCH_OC_NOT_ACTIVE;

#define EDCH_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/*==================[internal constants]======================================*/

#define EDCH_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/* Deviation MISRA-2 <+8> */ /* PRQA S 0306 8 */
/* !LINKSTO EDCH_028, 1
 * !LINKSTO EDCH_SDD_0278, 1
 */
/**
 * \brief Contains all configured addresses/pointer of EdchCvnDefinitionBlock
 */
EDCH_STATIC CONSTP2CONST(Edch_CvnDefBlockType, EDCH_CONST, EDCH_APPL_CONST)
  Edch_CvnTable_Ptr[EDCH_CVNTABLE_CNT] = EDCH_CVNTABLE_PTR;

/* !LINKSTO EDCH_002, 1
 */
/**
 * \brief Contains the reporting period
 *        of the configured OBD relevant diagnostics
 */
/* Deviation MISRA-4 <+3> */ /* PRQA S 3218 3 */
EDCH_STATIC CONST( Edch_Diagnostics_PeriodType, EDCH_CONST )
          Edch_SetEventStatus_Diagnostics_Period[EDCH_DIAGNOSTICS_COUNT]
                                                    = EDCH_DIAGNOSTICS_PERIOD;

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_SDD_0279, 1
 */
/**
 * \brief Contains the data/position
 *        of all configured OBD relevant coding switches
 */
EDCH_STATIC CONST(Edch_CodingSwitchType, EDCH_CONST)
  Edch_CodingReceive_CodingSwitch[EDCH_CODINGSW_CNT] = EDCH_CODING_SWITCHES;

/**
 * \brief Contains the Ids of coding blocks
 *        which contains configured OBD relevant coding switches
 */
EDCH_STATIC CONST(Coding_BlockIdType, EDCH_CONST)
        Edch_CalculateCodingCvn_CodingBlockId[EDCH_CODING_SWITCHES_BLOCK_CNT]
                                                   = EDCH_CODING_SWITCHES_BLOCK;
#endif

/**
 * \brief Contains the CRC initvalue
 *        of all configured EdchCvnDefinitionBlock resp SWEs
 */
/* Deviation MISRA-4 <+2> */ /* PRQA S 3218 2 */
EDCH_STATIC CONST(Edch_ChecksumValType, EDCH_CONST)
    Edch_CalculateSubCvn_CrcInit[EDCH_CVNTABLE_CNT] = EDCH_CVNTABLE_CRCINIT;

#define EDCH_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

#define EDCH_START_SEC_CONST_BOOLEAN
#include "MemMap.h"

/* !LINKSTO EDCH_002, 1
 */
/**
 * \brief Contains if the reporting type
 *        of the configured OBD relevant diagnostics is continuous
 */
EDCH_STATIC CONST( boolean, EDCH_CONST )
  Edch_Diagnostics_Continuous[EDCH_DIAGNOSTICS_COUNT] =
                                                    EDCH_DIAGNOSTICS_CONTINUOUS;

/**
 * \brief Contains if the reporting type
 *        of the configured OBD relevant diagnostics supports monitor enable status
 */
/* Deviation MISRA-4 <+3> */ /* PRQA S 3218 3 */
EDCH_STATIC CONST( boolean, EDCH_CONST )
  Edch_Diagnostics_Monitor_EN_Stat[EDCH_DIAGNOSTICS_COUNT] =
                                                    EDCH_DIAGNOSTICS_MONITOR_EN_STAT;

#define EDCH_STOP_SEC_CONST_BOOLEAN
#include "MemMap.h"

#define EDCH_START_SEC_CONST_8BIT
#include "MemMap.h"

/**
 * \brief Contains the ordered IMME have to send
 */
EDCH_STATIC CONST( uint8, EDCH_CONST )
  Edch_SendOrder_IMME[EDCH_DIAGNOSTICS_IMME_CNT] = EDCH_DIAGNOSTICS_IMME;

#define EDCH_STOP_SEC_CONST_8BIT
#include "MemMap.h"

/*==================[external data]===========================================*/

#define EDCH_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

/* !LINKSTO EDCH_059, 1
 */
/**
 * \brief Local mirror of the user data for CAL-ID,
 *        CVN and diagnostic status signals, have to write in ST_DIAG_OBD_DATA
 */
VAR(Edch_EventStatusIpduDataType, EDCH_VAR)Edch_sendIpduData[EDCH_MUX_MAX + 1U];

/* !LINKSTO EDCH_150, 1
 */
/**
 * \brief Checksum table for calculating CAL-ID
 */
VAR(Edch_ChecksumTableType, EDCH_VAR) Edch_CalIdChecksumTable;

/* !LINKSTO EDCH_151, 1
 */
/**
 * \brief Checksum table for calculating CVN
 */
VAR(Edch_ChecksumTableType, EDCH_VAR) Edch_CvnChecksumTable;

/**
 * \brief Actual calculated value for CAL-ID
 */
VAR(Edch_ChecksumValType, EDCH_VAR) Edch_CalId_val;

/**
 * \brief Actual calculated value for CVN
 */
VAR(Edch_ChecksumValType, EDCH_VAR) Edch_Cvn_val;

#if (EDCH_CODINGSW_CNT != 0U)
/**
 * \brief Actual calculated value for reference coding CVN
 */
VAR(Edch_ChecksumValType, EDCH_VAR) Edch_RefCodCvn_val;
/**
 * \brief Actual calculated value for sub coding CVN
 */
VAR(Edch_ChecksumValType, EDCH_VAR) Edch_SubCodCvn_val;
#endif

/**
 * \brief Actual calculated values for all sub CVN
 */
VAR(Edch_ChecksumValType, EDCH_VAR) Edch_SubCvn_val[EDCH_CVNTABLE_CNT];

/* !LINKSTO EDCH_211, 2
 */
/**
 * \brief Last known status of the OBD operation cycle
 */
VAR(Edch_OperationCycleStateType, EDCH_VAR) Edch_OperationCycleState;

#define EDCH_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

/*==================[internal data]===========================================*/

#define EDCH_START_SEC_VAR_BOOLEAN
#include "MemMap.h"

/* !LINKSTO EDCH_315, 1
 * !LINKSTO EDCH_317, 1
 * !LINKSTO EDCH_318, 1
 * !LINKSTO EDCH_319, 1
 * !LINKSTO EDCH_320, 1
 * !LINKSTO EDCH_326, 1
 * !LINKSTO EDCH_328, 2
 * !LINKSTO EDCH_329, 2
 * !LINKSTO EDCH_330, 2
 * !LINKSTO EDCH_331, 2
 * !LINKSTO EDCH_332, 2
 * !LINKSTO EDCH_333, 2
 * !LINKSTO EDCH_334, 2
 * !LINKSTO EDCH_335, 2
 * !LINKSTO EDCH_336, 2
 * !LINKSTO EDCH_337, 2
 * !LINKSTO EDCH_338, 2
 * !LINKSTO EDCH_339, 2
 * !LINKSTO EDCH_340, 2
 */
/**
 * \brief Initialization state of module
 */
EDCH_STATIC VAR(boolean, EDCH_VAR) Edch_Initialized = FALSE;

  /* !LINKSTO EDCH_316, 1
   */
/**
 * \brief Guard for concurrent call of Edch_InitSend
 */
/* Deviation MISRA-4 <+1> */ /* PRQA S 3218 1 */
EDCH_STATIC VAR(boolean, EDCH_VAR) Edch_InitSend_guard = FALSE;

#define EDCH_STOP_SEC_VAR_BOOLEAN
#include "MemMap.h"


#define EDCH_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

/* !LINKSTO EDCH_SDD_0285, 1
 */
/**
 * \brief State of all configured OBD relevant diagnostics
 *        in respect to the event triggered send mode
 */
EDCH_STATIC VAR(Edch_EventTriggerListType, EDCH_VAR)
                                  Edch_EventTriggerList[EDCH_DIAGNOSTICS_COUNT];

/* !LINKSTO EDCH_007, 1
 */
/**
 * \brief Special anchor element for head of event triggered send list
 */
EDCH_STATIC VAR(Edch_EventTriggerListType, EDCH_VAR) Edch_EventTriggerHead;

/* !LINKSTO EDCH_007, 1
 */
/**
 * \brief Pointer to end of event triggered send list
 */
EDCH_STATIC VAR(Edch_EventTriggerListPtrType, EDCH_VAR) Edch_EventTriggerEnd;

/* !LINKSTO EDCH_SDD_0286, 1
 */
/**
 * \brief Actual calculation state/mark of CAL-ID
 */
EDCH_STATIC VAR(Edch_ChecksumStateType, EDCH_VAR) Edch_CalIdState;

/* !LINKSTO EDCH_SDD_0287, 1
 */
/**
 * \brief Actual calculation state/mark of CVN
 */
EDCH_STATIC VAR(Edch_ChecksumStateType, EDCH_VAR) Edch_CvnState;

/* !LINKSTO EDCH_SDD_0288, 1
 */
/**
 * \brief Actual calculation states/marks of all sub CVN
 */
EDCH_STATIC VAR(Edch_ChecksumStateType, EDCH_VAR)
                                            Edch_SubCvnState[EDCH_CVNTABLE_CNT];

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_SDD_0289, 1
 */
/**
 * \brief Actual calculation state/mark of reference coding CVN
 */
EDCH_STATIC VAR(Edch_ChecksumStateType, EDCH_VAR) Edch_RefCodCvnState;
/* !LINKSTO EDCH_SDD_0290, 1
 */
/**
 * \brief Actual calculation state/mark of sub coding CVN
 */
EDCH_STATIC VAR(Edch_ChecksumStateType, EDCH_VAR) Edch_SubCodCvnState;
#endif

/**
 * \brief Variables for control asynchronous runs of Edch_CalculateSubCvn
 */
EDCH_STATIC VAR(Edch_CalculateSubCvn_localType, EDCH_VAR)
                                                     Edch_CalculateSubCvn_local;

#if (EDCH_CODINGSW_CNT != 0U)
/**
 * \brief Variables for control asynchronous runs of Edch_CalculateCodingCvn
 */
EDCH_STATIC VAR(Edch_CalculateCodingCvn_localType, EDCH_VAR)
                                                  Edch_CalculateCodingCvn_local;
#endif

/**
 * \brief Control runs of Edch_SendCyclic
 */
EDCH_STATIC VAR(Edch_SendCyclic_ctrlType, EDCH_VAR) Edch_SendCyclic_ctrl;

#define EDCH_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"


#define EDCH_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_153, 1
 */
/**
 * \brief Checksum table for calculating coding CVN accros
 */
VAR(Edch_CodingChecksumTableType, EDCH_VAR) CodingChecksumTable;

#endif


/**
 * \brief Last known state of KL15/Terminal15
 */
EDCH_STATIC VAR(uint8, EDCH_VAR) Edch_Terminal15State;

/**
 * \brief Last known state of signal Anforderung_Reset_OBD_Diagnose_Fahrdynamik
 */
EDCH_STATIC VAR(UInt2, EDCH_VAR) SigObdReset; 

#if (EDCH_CODINGSW_CNT != 0U)
/**
 * \brief Count of Blocks requested on Coding are not yet responded
 */
EDCH_STATIC VAR(uint8, EDCH_VAR) Edch_CountOfRequestedCodingBlocks;

#endif

#define EDCH_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"


#define EDCH_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"

/**
 * \brief Contains occurrence timer of the configured OBD relevant diagnostics
 */
EDCH_STATIC VAR(uint16, EDCH_VAR)
                                Edch_Diagnostics_OccCnt[EDCH_DIAGNOSTICS_COUNT];

#define EDCH_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"

/*==================[external function definitions]===========================*/

#define EDCH_START_SEC_APPL_CODE
#include "MemMap.h"

/* !LINKSTO EDCH_060, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_Init
 *
 * This function shall initialize the EDCH module.
 *
 * \global Edch_Initialized
 * \global Edch_SendCyclic_ctrl
 * \global Edch_Terminal15State
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerHead
 * \global Edch_EventTriggerEnd
 * \global Edch_OperationCycleState
 * \global Edch_CalculateSubCvn_local
 * \global Edch_CalculateCodingCvn_local
 * \global Edch_CountOfRequestedCodingBlocks
 * \global Edch_CalId_val
 * \global Edch_CalIdState
 * \global Edch_CvnState
 * \global Edch_SubCvnState
 * \global Edch_SubCodCvnState
 * \global Edch_RefCodCvn_val
 * \global Edch_RefCodCvnState
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
FUNC( void, EDCH_APPL_CODE ) Edch_Init
(
  void
)
{
  uint16_least diagIdx;
  uint16_least subCvnIdx;
  
/* !LINKSTO EDCH_315, 1
 * !LINKSTO EDCH_317, 1
 * !LINKSTO EDCH_318, 1
 * !LINKSTO EDCH_319, 1
 * !LINKSTO EDCH_320, 1
 * !LINKSTO EDCH_326, 1
 * !LINKSTO EDCH_328, 2
 * !LINKSTO EDCH_329, 2
 * !LINKSTO EDCH_330, 2
 * !LINKSTO EDCH_331, 2
 * !LINKSTO EDCH_332, 2
 * !LINKSTO EDCH_333, 2
 * !LINKSTO EDCH_334, 2
 * !LINKSTO EDCH_335, 2
 * !LINKSTO EDCH_336, 2
 * !LINKSTO EDCH_337, 2
 * !LINKSTO EDCH_338, 2
 * !LINKSTO EDCH_339, 2
 * !LINKSTO EDCH_340, 2
 */
  Edch_Initialized = FALSE;

#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  /*--- check if NvM RAM initialized correctly ---*/
  /* !LINKSTO EDCH_344, 1
   */
  if(Edch_CheckNvMStatus() != E_OK)
  {
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_INIT, EDCH_E_NVM);
  }
  else
#endif
  {
    /*--- Pre-initialize cyclic send process ---*/
    Edch_SendCyclic_ctrl.burstMode = TRUE;
    Edch_SendCyclic_ctrl.cyclicalDelayed = FALSE;
    Edch_SendCyclic_ctrl.lastImme = EDCH_IMME_INVALID;
    Edch_SendCyclic_ctrl.lastSendError = RTE_E_OK;

    Edch_SendCyclic_ctrl.burstImmeIdx = 0U;
    Edch_SendCyclic_ctrl.cyclicalImmeIdx = 0U;

    /* !LINKSTO EDCH_264, 1
     */
    Edch_Terminal15State = EDCH_K15_NOT_ACTIVE;

    /* !LINKSTO EDCH_358, 1
     */
    SigObdReset = ST_CLEAR_MEM_OFF;

    /* !LINKSTO EDCH_231, 2
     */
    Edch_SendCyclic_ctrl.wait = EDCH_STOP_IN_SENDCYCLIC;

    /*--- Initialize Edch_EventTriggerList ---*/
    for(diagIdx=0U;diagIdx<EDCH_DIAGNOSTICS_COUNT;diagIdx++)
    {
      Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
      Edch_EventTriggerList[diagIdx].idx = (Edch_DiagIdxType)diagIdx;
      Edch_EventTriggerList[diagIdx].next = NULL_PTR;
      Edch_EventTriggerList[diagIdx].prev = NULL_PTR;
    }

    /* !LINKSTO EDCH_007, 1
     */
    Edch_EventTriggerHead.idx = 0x00U;
    Edch_EventTriggerHead.marker = 0x0000U;
    Edch_EventTriggerHead.next = NULL_PTR;
    Edch_EventTriggerHead.prev = NULL_PTR;

    /* !LINKSTO EDCH_007, 1
     */
    Edch_EventTriggerEnd = &Edch_EventTriggerHead;

    /*--- Initialize ST_DIAG_OBD and ST_DIAG_OBDDATA mirrors ---*/
    /* !LINKSTO EDCH_SDD_0201, 1
     */
    Edch_Init_SendData();

    /*--- initialization of module global (static) variables ---*/

    /* Edch_CalculateSubCvn: */
    Edch_CalculateSubCvn_local.synchflag = EDCH_CALSUBCVN_INVALID;
    Edch_CalculateSubCvn_local.tableIdx = 0U;
    Edch_CalculateSubCvn_local.subCvn_idx = EDCH_CALSUBCVN_INVALID;
    Edch_CalculateSubCvn_local.procLen = 0U;
    Edch_CalculateSubCvn_local.subCvn_val = 0U;

#if (EDCH_CODINGSW_CNT != 0U)
    /* Edch_CalculateCodingCvn: */
    Edch_CalculateCodingCvn_local.synchflag = EDCH_CALCODCVN_NO;
    Edch_CalculateCodingCvn_local.codCvn_type = EDCH_CALCODCVN_NO;
    Edch_CalculateCodingCvn_local.runLen = 0U;
    Edch_CalculateCodingCvn_local.codCvn_val = 0U;

    Edch_CountOfRequestedCodingBlocks = 0U;
#endif

    /*--- initialization for first ECU start ---*/
    if (Edch_OperationCycleState == EDCH_OC_NOT_ACTIVE)
    {
      /*--- Initialize OBD operation cycle ---*/
      /* !LINKSTO EDCH_359, 1
       */
      Edch_OperationCycleState = EDCH_OC_ACTIVE;
      /* A WriteBlock-call only return value != E_OK, if:
       * - NvM is not initialized,
       * - no permanent RAM block is defined,
       * - request for actual "BlockId" is still pending,
       * - (immediate/standard) request queue is full or
       * - data is write protected
       * All that can be checked and negated during integration phase
       * (DET-entries)
       */
      (void)Rte_Call_NvMBlock_OperationCycleState_WriteBlock(NULL_PTR);

      /* !LINKSTO EDCH_360, 2
       */
      /* The following Rte-call only returns value !=E_OK,
       * if the given operation cycle is not configured.
       * This should be checked and negated during integration phase.
       */
      (void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_END);
      (void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_START);
    }

    /*--- initialization for first start after reprogramming ---*/
    /* !LINKSTO EDCH_SDD_0201, 1
     */
    Edch_Init_First();

    /*--- initialization of checksum states ---*/
    /* !LINKSTO EDCH_261, 1
     */
    if(Edch_CalId_val == EDCH_CALID_DEFAULT_VAL)
    {
      /* !LINKSTO EDCH_064, 1
       */
      Edch_CalIdState = EDCH_CRC_READY;
    }
    else
    {
      Edch_CalIdState = EDCH_CRC_VALID;
    }
    Edch_Crc2Pdu(Edch_CalId_val, EDCH_IMME_CALID);

    /* !LINKSTO EDCH_262, 2
     */
    if(Edch_Cvn_val == EDCH_CALID_DEFAULT_VAL)
    {
      /* !LINKSTO EDCH_065, 1
       */
      Edch_CvnState = EDCH_CRC_READY;
    }
    else
    {
      Edch_CvnState = EDCH_CRC_VALID;
    }
    Edch_Crc2Pdu(Edch_Cvn_val, EDCH_IMME_CVN);

    /* !LINKSTO EDCH_311, 1
     */
    for(subCvnIdx=0U;subCvnIdx<EDCH_CVNTABLE_CNT;subCvnIdx++)
    {
      Edch_SubCvnState[subCvnIdx] = EDCH_CRC_READY;
    }

#if (EDCH_CODINGSW_CNT != 0U)
    /* !LINKSTO EDCH_312, 1
     */
    Edch_SubCodCvnState =EDCH_CRC_READY;
    /* !LINKSTO EDCH_263, 1
     */
    if(Edch_RefCodCvn_val == EDCH_CALID_DEFAULT_VAL)
    {
      /* !LINKSTO EDCH_259, 1
       */
      Edch_RefCodCvnState = EDCH_CRC_READY;
    }
    else
    {
      Edch_RefCodCvnState = EDCH_CRC_VALID;
    }
#endif

  /* !LINKSTO EDCH_315, 1
   * !LINKSTO EDCH_317, 1
   * !LINKSTO EDCH_318, 1
   * !LINKSTO EDCH_319, 1
   * !LINKSTO EDCH_320, 1
   * !LINKSTO EDCH_326, 1
   * !LINKSTO EDCH_328, 2
   * !LINKSTO EDCH_329, 2
   * !LINKSTO EDCH_330, 2
   * !LINKSTO EDCH_331, 2
   * !LINKSTO EDCH_332, 2
   * !LINKSTO EDCH_333, 2
   * !LINKSTO EDCH_334, 2
   * !LINKSTO EDCH_335, 2
   * !LINKSTO EDCH_336, 2
   * !LINKSTO EDCH_337, 2
   * !LINKSTO EDCH_338, 2
   * !LINKSTO EDCH_339, 2
   * !LINKSTO EDCH_340, 2
   */
    Edch_Initialized = TRUE;
    /* Synchronize EDCH and DEM Event states */
    /* !LINKSTO EDCH_361, 1
     */
    Edch_GetEventStatus();
              
    /* !LINKSTO EDCH_069, 2
     */
    Edch_InitSend();
  }
}

/* !LINKSTO EDCH_070, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_EventStatusChanged
 *
 * This function receive changes of the status of a DemEvent.
 *
 * \global Edch_Initialized
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerEnd
 * \global Edch_sendIpduData
 *
 * \param[in] Idx Index of the Event. Corresponds to the order
 *            of the EdchEventDiagnostics equivalent in the EDCH configuration.
 * \param[in] EventStatusOld Previous status of the event
 * \param[in] EventStatusNew New/actual status of the event
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
/* Deviation MISRA-3 <+3> */ /* PRQA S 1330 3 */
FUNC(Std_ReturnType, EDCH_APPL_CODE) Edch_EventStatusChanged
(
  Edch_EventIdxType DemIdx,
  Dem_EventStatusExtendedType EventStatusOld,
  Dem_EventStatusExtendedType EventStatusNew
)
{
  uint8 demBit;

  /* ----- NXTR PATCH START ----- */
  /* Added By: K. Smith (Nxtr)
   * Date Added: 02Jun14
   *
   * Reason: The callback from the Dem is passing the EventID of the Dem NOT the
   * Edch callback. Instead of modifying the Dem code to pass the Edch index,
   * the decision was to modify this function in case other callbacks
   * are added to the Dem for other modules.
   *
   * Note: Function argument 1 was renamed to DemIdx from Idx. Idx is included
   * below to allow the rest of the function to remain the same.
   */
  Edch_EventIdxType Idx;
  uint8 loopIdx_Cnt_T_u8;
  /* Variable to determine whether Index has been found or not */
  uint8 IndexAvailable;
  
  /* Set the index available to zero and update to 1 when the index is available */
  IndexAvailable = 0;
  for (loopIdx_Cnt_T_u8 = 0U; loopIdx_Cnt_T_u8 < D_NUMOFEDCHDIAG_CNT_U8; loopIdx_Cnt_T_u8++)
  {
	  if(DemIdx == t_EdchRelDiagTbl_str[loopIdx_Cnt_T_u8].DEMEventId)
	  {
		  Idx = loopIdx_Cnt_T_u8;
      IndexAvailable = 1;
		  break;
	  }
  }
  /* Continue only if the index is available if not ignore the function call from Dem */
  if(IndexAvailable == 1)
  {
    /* ----- NXTR PATCH END ----- */

   /* !LINKSTO EDCH_328, 2
   */
    if(Edch_Initialized == TRUE)
    {
      if(((uint8)(EventStatusOld ^ EventStatusNew) & EDCH_DEM_MASK) != 0U)
      {
        /* ExclusiveArea used to guard concurency access to
         * Edch_EventTriggerList and Edch_EventTriggerEnd */
        Rte_Enter_ExclusiveArea_0();
        if(Edch_EventTriggerList[Idx].marker == EDCH_REPORT_NOT)
        {
          /* !LINKSTO EDCH_072, 1
           */
          Edch_EventTriggerEnd->next = &(Edch_EventTriggerList[Idx]);
          Edch_EventTriggerList[Idx].prev = Edch_EventTriggerEnd;
          Edch_EventTriggerEnd = &(Edch_EventTriggerList[Idx]);
          Edch_EventTriggerList[Idx].next = NULL_PTR;
        }
        /* !LINKSTO EDCH_074, 1
         */
        if((Edch_EventTriggerList[Idx].marker == EDCH_REPORT_NOT) ||
           (Edch_EventTriggerList[Idx].marker == EDCH_REPORT_PRE)
          )
        {
          Edch_EventTriggerList[Idx].marker = EDCH_REPORT;
        }
        Rte_Exit_ExclusiveArea_0();
        
        if(((uint8)(EventStatusOld ^ EventStatusNew) &
            EDCH_DEM_NOTCOMPL_THIS_OC
           ) != 0U
          )
        {
          demBit = (EventStatusNew & EDCH_DEM_NOTCOMPL_THIS_OC) >>
                                          EDCH_DEM_NOTCOMPL_THIS_OC_BITORDER;
          /* !LINKSTO EDCH_075, 1
           */
          EDCH_SET_DIAGIDX_FLAGORDER_VAL(Idx,EDCH_TEST_NOT_COMPL_BITORDER,demBit);
        }
    
        if(((Dem_EventStatusExtendedType)(EventStatusOld ^ EventStatusNew) &
            EDCH_DEM_FAILED_THIS_OC
           ) != 0U
          )
        {
          demBit = (EventStatusNew & EDCH_DEM_FAILED_THIS_OC) >>
                                          EDCH_DEM_FAILED_THIS_OC_BITORDER;
          /* !LINKSTO EDCH_077, 1
           */
          EDCH_SET_DIAGIDX_FLAGORDER_VAL(Idx,EDCH_TEST_FAILED_BITORDER,demBit);
        }
    
        if(((uint8)(EventStatusOld ^ EventStatusNew) & EDCH_DEM_FAILED) != 0U)
        {
          demBit = (EventStatusNew & EDCH_DEM_FAILED) >> EDCH_DEM_FAILED_BITORDER;
          /* !LINKSTO EDCH_079, 1
           */
          EDCH_SET_DIAGIDX_FLAGORDER_VAL(Idx,EDCH_TEST_FAILED_CURR_BITORDER,demBit);
          /* !LINKSTO EDCH_081, 1
           */
          if(demBit==0x01U)
          {
            Edch_EventTriggerList[Idx].marker = EDCH_REPORT_FAIL;
          }
        }
      }
    }
  }  
  return E_OK;
}

/* !LINKSTO EDCH_118, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_InitSend
 *
 * This function shall initiate the cyclical send algorithm.
 *
 * \global Edch_InitSend_guard
 * \global Edch_Terminal15State
 * \global Edch_CvnState
 * \global Edch_CalIdState
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerHead
 * \global Edch_EventTriggerEnd
 * \global Edch_SendCyclic_ctrl
 *
 * \param[in] --  
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_InitSend
(
  void
)
{
  /* !LINKSTO EDCH_354, 2
   */
  if(Edch_Initialized == TRUE)
  {
    UInt4 SigKl15;
    uint16_least diagIdx;
    boolean endImmediately = TRUE;

    /* !LINKSTO EDCH_316, 1
     */
    /* ExclusiveArea used to guard concurrency access
     * to Edch_InitSend resp. to Edch_InitSend_guard */
    Rte_Enter_ExclusiveArea_0();
    if(Edch_InitSend_guard == FALSE)
    {
      Edch_InitSend_guard = TRUE;
      endImmediately = FALSE;
    }
    Rte_Exit_ExclusiveArea_0();

    if(endImmediately == FALSE)
    {
      /* !LINKSTO EDCH_235, 1
       */
      /* The following Rte-call only returns value !=E_OK, if:
       * - the requested signal contains values, explicit declared as invalid
       * - the value of the requested signal is outdated
       * Both features are not intended.
       */
      (void)Rte_Read_ST_KL_ST_KL(&SigKl15);

      if((SigKl15<=EDCH_K15_ACTIVE_LOWRANGE)||(SigKl15>=EDCH_K15_ACTIVE_UPPERRANGE))
      {
        /* !LINKSTO EDCH_236, 1
         */
        Edch_Terminal15State = EDCH_K15_NOT_ACTIVE;
      }
      else
      {
        /* !LINKSTO EDCH_267, 1
         */
        if(Edch_Terminal15State != EDCH_K15_ACTIVE)
        {
          /* !LINKSTO EDCH_268, 1
           */
          Edch_Terminal15State = EDCH_K15_ACTIVE;

          /* !LINKSTO EDCH_119, 1
           */
          /* ExclusiveArea used to guard concurency access to
           * Edch_EventTriggerList, Edch_EventTriggerHead
           * and Edch_EventTriggerEnd */
          Rte_Enter_ExclusiveArea_0();

          /*--- Initialize Edch_EventTriggerList ---*/
          for(diagIdx=0U;diagIdx<EDCH_DIAGNOSTICS_COUNT;diagIdx++)
          {
            Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
            Edch_EventTriggerList[diagIdx].idx = (Edch_DiagIdxType)diagIdx;
            Edch_EventTriggerList[diagIdx].next = NULL_PTR;
            Edch_EventTriggerList[diagIdx].prev = NULL_PTR;
          }

          Edch_EventTriggerHead.idx = 0x00U;
          Edch_EventTriggerHead.marker = 0x0000U;
          Edch_EventTriggerHead.next = NULL_PTR;
          Edch_EventTriggerHead.prev = NULL_PTR;

          Edch_EventTriggerEnd = &Edch_EventTriggerHead;

          Rte_Exit_ExclusiveArea_0();

          /* !LINKSTO EDCH_120, 1
           */
          Edch_SendCyclic_ctrl.burstMode = TRUE;

          /* !LINKSTO EDCH_121, 1
           */
          Edch_SendCyclic_ctrl.burstImmeIdx = 0U;

          /* !LINKSTO EDCH_122, 1
           */
          Edch_SendCyclic_ctrl.wait = EDCH_WAIT_500MS_IN_SENDCYCLIC;

          /* !LINKSTO EDCH_357, 1
           */
          if (Edch_OperationCycleState == EDCH_OC_QUALIFIED)
          {
            /* New Qualified Driving Cycle detected */

            /*--- Initialize OBD operation cycle ---*/
            /* !LINKSTO EDCH_232, 2
             */
            Edch_OperationCycleState = EDCH_OC_ACTIVE;

            /* A WriteBlock-call only return value != E_OK, if:
             * - NvM is not initialized,
             * - no permanent RAM block is defined,
             * - request for actual "BlockId" is still pending,
             * - (immediate/standard) request queue is full or
             * - data is write protected
             * All that can be checked and negated during integration phase
             * (DET-entries)
             */
            (void)Rte_Call_NvMBlock_OperationCycleState_WriteBlock(NULL_PTR);

            /* !LINKSTO EDCH_291, 2
             */
            Edch_CvnState = EDCH_CRC_READY;

            /* !LINKSTO EDCH_156, 2
             */
            for(diagIdx=0U;diagIdx<EDCH_CVNTABLE_CNT;diagIdx++)
            {
              Edch_SubCvnState[diagIdx] = EDCH_CRC_READY;
            }
            #if (EDCH_CODINGSW_CNT != 0U)
              Edch_SubCodCvnState = EDCH_CRC_READY;
            #endif

            /* !LINKSTO EDCH_292, 2
             */
            Edch_CalIdState = EDCH_CRC_READY;

            /* !LINKSTO EDCH_232, 2
             */
            /* The following Rte-call only returns value !=E_OK,
             * if the given operation cycle is not configured.
             * This should be checked and negated during integration phase.
             */
	(void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_END);
	(void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_START);
          }
        }
      }
      /* !LINKSTO EDCH_316, 1
       */
      Edch_InitSend_guard = FALSE;
    }
  }
}

/* !LINKSTO EDCH_082, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic
 *
 * This function send the states of the diagnostic events,
 * the CAL-ID and the CVN to the OBD Host.
 * Evaluates the right send mode (burst, cyclical or event triggered)
 * and if necessary adapt the status of the Events.
 * The Function is called cyclical every 160msec
 *
 * \global Edch_Initialized
 * \global Edch_SendCyclic_ctrl
 * \global Edch_EventTriggerHead
 *
 * \param[in] --  
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
/* PRQA S 5200 Edch_SendCyclic_5200 *//* Violation of metric STMIF.
   Reason: Effected by module design. */
/* PRQA S 5203 Edch_SendCyclic_5203 *//* Violation of metric STCAL.
   Reason: Effected by module design. */
FUNC(void, EDCH_APPL_CODE) Edch_SendCyclic
(
  void
)
{
  /* !LINKSTO EDCH_329, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_083, 1
     */
    if(Edch_SendCyclic_ctrl.wait > 0x00U)
    {
      /* !LINKSTO EDCH_233, 1
       */
      if(Edch_SendCyclic_ctrl.wait != EDCH_STOP_IN_SENDCYCLIC)
      {
        --Edch_SendCyclic_ctrl.wait;
      }
    }
    else
    {
      /* !LINKSTO EDCH_347, 1
       */
      const Std_ReturnType MuxImmeFeedback = Edch_CheckMuxImmeFeedback();

      Edch_SendCyclic_PrepareOccurrenceTimer();

      /* !LINKSTO EDCH_348, 1
       */
      if(MuxImmeFeedback == RTE_E_NO_DATA)
      {
        /* Do nothing ! */
      }
      /* !LINKSTO EDCH_349, 2
       */
      else if( (MuxImmeFeedback == RTE_E_COM_STOPPED) ||
               (MuxImmeFeedback == RTE_E_TIMEOUT)
             )
      {
        /* !LINKSTO EDCH_349, 2
         */
        Edch_SendCyclic_ctrl.lastSendError = Rte_Write_ST_DIAG_OBD_MUX_IMME(Edch_SendCyclic_ctrl.lastImme);
      }
      else /* RTE_E_TRANSMIT_ACK */
      {
        /* !LINKSTO EDCH_086, 1
         */
        if(Edch_SendCyclic_ctrl.burstMode == TRUE)
        {
          /* !LINKSTO EDCH_SDD_0203, 1
           */
          Edch_SendCyclic_BurstMode();
        }
        else
        {

          /* !LINKSTO EDCH_094, 1
           */
          Edch_SendCyclic_ctrl.cycleTimer = (Edch_SendCyclic_ctrl.cycleTimer + 1U)
                                                   % EDCH_REPORT2BURSTCYCLE_RATIO;

          if(EDCH_EVENTTRIGGERLIST_HEAD != NULL_PTR)
          /* !LINKSTO EDCH_092, 1
           */
          {
            Edch_EventIdxType triggDiagnIdx = 0;
            boolean doSendEventTriggeredCall = FALSE;

            /* !LINKSTO EDCH_084, 1
             */
            /* Range of Edch_SendCyclic_ctrl.aliveCnt is 0x00U to 0x0EU */
            Edch_SendCyclic_ctrl.aliveCnt =
                                     (Edch_SendCyclic_ctrl.aliveCnt + 1U) % 0x0FU;

            /* !LINKSTO EDCH_085, 1
             */
            /* The following Rte-call only returns value != E_OK,
             * if the COM service is not available.
             * This should be checked and negated during integration phase.
             */
            (void)Rte_Write_ST_DIAG_OBD_ALIVE
                                         ((UInt4)Edch_SendCyclic_ctrl.aliveCnt);

            /* ExclusiveArea used to guard concurency access
             * to EDCH_EVENTTRIGGERLIST_HEAD */
            Rte_Enter_ExclusiveArea_0();
            if(EDCH_EVENTTRIGGERLIST_HEAD != NULL_PTR)
            {
              triggDiagnIdx = EDCH_EVENTTRIGGERLIST_HEAD->idx;
              doSendEventTriggeredCall = TRUE;
            }
            Rte_Exit_ExclusiveArea_0();

            if(doSendEventTriggeredCall == TRUE)
            {
              /* !LINKSTO EDCH_SDD_0203, 1
               */
              Edch_SendCyclic_EventTriggeredMode(triggDiagnIdx);
            }
          }
          else
          {
            /* !LINKSTO EDCH_103, 1
             */
            /* !LINKSTO EDCH_104, 1
             */
            if((Edch_SendCyclic_ctrl.cycleTimer == 0x00U) ||
                (Edch_SendCyclic_ctrl.cyclicalDelayed == TRUE)
              )
            {
              /* !LINKSTO EDCH_084, 1
               */
              /* Range of Edch_SendCyclic_ctrl.aliveCnt is 0x00U to 0x0EU */
              Edch_SendCyclic_ctrl.aliveCnt =
                                     (Edch_SendCyclic_ctrl.aliveCnt + 1U) % 0x0FU;

              /* !LINKSTO EDCH_085, 1
               */
              /* The following Rte-call only returns value != E_OK,
               * if the COM service is not available.
               * This should be checked and negated during integration phase.
               */
              (void)Rte_Write_ST_DIAG_OBD_ALIVE
                                         ((UInt4)Edch_SendCyclic_ctrl.aliveCnt);
              /* !LINKSTO EDCH_SDD_0024, 1
               */
              Edch_SendCyclic_CyclicalMode();
            }
          }
        }
      }
    }
  }
}
/* PRQA L:Edch_SendCyclic_5200 */
/* PRQA L:Edch_SendCyclic_5203 */

/* !LINKSTO EDCH_130, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SetEventStatus
 *
 * This function registers the occurrence of the diagnostic report
 * to update the status EDCH_TEST_ACTIVE.
 *
 * \global Edch_Initialized
 * \global Edch_Diagnostics_OccCnt
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerEnd
 *
 * \param[in] Idx Index of the Event. Corresponds to the order
 *            of the EdchEventDiagnostics equivalent in the EDCH configuration.
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_SetEventStatus
(
  Edch_EventIdxType Idx
)
{
  /* !LINKSTO EDCH_333, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_131, 1
     */
    Edch_Diagnostics_OccCnt[Idx] =
      ((Edch_SetEventStatus_Diagnostics_Period[Idx] -1U) / EDCH_BURSTCYCLE_MS)
      + 1U;

    /* ExclusiveArea used to guard concurency access to
     * Edch_EventTriggerList and Edch_EventTriggerEnd */
    Rte_Enter_ExclusiveArea_0();

    if((EDCH_GET_DIAGIDX_FLAGORDER(Idx,EDCH_TEST_ACTIVE_BITORDER)) == 0x00U)
    /* !LINKSTO EDCH_285, 1
     */
    {
      if(Edch_EventTriggerList[Idx].marker == EDCH_REPORT_NOT)
      {
        /* put on the end of the event trigger list */
        Edch_EventTriggerEnd->next = &Edch_EventTriggerList[Idx];
        Edch_EventTriggerList[Idx].prev = Edch_EventTriggerEnd;
        Edch_EventTriggerEnd = &Edch_EventTriggerList[Idx];
        Edch_EventTriggerEnd->next = NULL_PTR;
        Edch_EventTriggerEnd->marker = EDCH_REPORT_PRE;
      }
    }
    else
    /* !LINKSTO EDCH_286, 1
     */
    {
      if(Edch_EventTriggerList[Idx].marker == EDCH_REPORT_PRE)
      {
        Edch_RemoveFromEventList(Idx);
      }
    }
    Rte_Exit_ExclusiveArea_0();
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_319, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID,
               EDCH_SID_EVENSTATUSCHANGED_BASE+EDCH_DIAGNOSTICS_COUNT+Idx,
               EDCH_E_INIT
              );
  }
#endif
}

/* !LINKSTO EDCH_144, 2
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_OperationCycleUpdated
 *
 * This function receives the status of the OBD cycle from the OBD Host
 * and notifies the module if the current Driving Cycle was qualified.
 *
 * \global Edch_Initialized
 * \global Edch_OperationCycleState
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The operation cycle is never stopped but only restarted. 
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_OperationCycleUpdated
(
  void
)
{
  UInt6 Status_OBD_Zyklus;

  /* !LINKSTO EDCH_334, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_145, 1
     */
    /* The following Rte-call only returns value !=E_OK, if:
     * - the requested signal contains values, explicit declared as invalid
     * - the value of the requested signal is outdated
     * Both features are not intended.
     */
    (void)Rte_Read_ST_OBD_CYCLE_Status_OBD_Zyklus(&Status_OBD_Zyklus);

    /* !LINKSTO EDCH_146, 2
     */
    if(((Status_OBD_Zyklus & EDCH_OBD_ZYKLUS_MASK) == EDCH_OBD_ZYKLUS_START) &&
        (Edch_OperationCycleState == EDCH_OC_ACTIVE))
    {
      Edch_OperationCycleState = EDCH_OC_QUALIFIED;

      /* A WriteBlock-call only return value != E_OK, if:
       * - NvM is not initialized,
       * - no permanent RAM block is defined,
       * - request for actual "BlockId" is still pending,
       * - (immediate/standard) request queue is full or
       * - data is write protected
       * All that can be checked and negated during integration phase
       * (DET-entries)
       */
      (void)Rte_Call_NvMBlock_OperationCycleState_WriteBlock(NULL_PTR);
    }
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_320, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_OPERATIONCYCLEUPDATED, EDCH_E_INIT);
  }
#endif
}

/* !LINKSTO EDCH_109, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_ClearErrorMem
 *
 * This function is triggered by the reception of the signal
 * Anforderung_Reset_OBD_Diagnose_Fahrdynamik.
 * Thereupon the function update the local recognized status
 * and instructs the DEM to reset the status, for every OBD relevant event.
 * Additional the function reinitialize the send process,
 * and instructs the DEM to reset the operation cycle of the OBD events.
 *
 * \global Edch_Initialized
 * \global Edch_sendIpduData
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
/* PRQA S 5203 Edch_ClearErrorMem_End *//* Violation of metric STCAL.
   Reason: Effected by module design. */
FUNC(void, EDCH_APPL_CODE) Edch_ClearErrorMem
(
  void
)
{
  UInt2 SigObdResetNew;
  uint16_least diagIdx;

  /* !LINKSTO EDCH_330, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_110, 1
     */
    /* The following Rte-call only returns value !=E_OK, if:
     * - the requested signal contains values, explicit declared as invalid
     * - the value of the requested signal is outdated
     * Both features are not intended.
     */
    (void)Rte_Read_ST_OBD_RESET_Anforderung_Reset_OBD_Diagnose_Fahrdynamik
                                                               (&SigObdResetNew);

    /* Perform the actions once when the clear memory flag is set */
    if( (SigObdReset != SigObdResetNew) && (SigObdResetNew == ST_CLEAR_MEM_ON) )
    {
      /* !LINKSTO EDCH_111, 1
       */
      EDCH_RESETEVENTSTATUS_ALL();

      /* !LINKSTO EDCH_112, 1
       */
      /* The following Rte-call only returns value !=E_OK,
       * if the given operation cycle is not configured.
       * This should be checked and negated during integration phase.
       */
      (void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_END);
      (void)Rte_Call_RP_Dem_CYCLE_SetOperationCycleState
                                             (OBD_CYCLE, DEM_CYCLE_STATE_START);

      /* !LINKSTO EDCH_116, 2
       */
      /* ExclusiveArea used to guard concurency access to
       * Edch_EventTriggerList, Edch_EventTriggerHead
       * and Edch_EventTriggerEnd */
      Rte_Enter_ExclusiveArea_0();

      /*--- Initialize Edch_EventTriggerList ---*/
      for(diagIdx=0U;diagIdx<EDCH_DIAGNOSTICS_COUNT;diagIdx++)
      {
        Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
        Edch_EventTriggerList[diagIdx].idx = (Edch_DiagIdxType)diagIdx;
        Edch_EventTriggerList[diagIdx].next = NULL_PTR;
        Edch_EventTriggerList[diagIdx].prev = NULL_PTR;
      }

      Edch_EventTriggerHead.idx = 0x00U;
      Edch_EventTriggerHead.marker = 0x0000U;
      Edch_EventTriggerHead.next = NULL_PTR;
      Edch_EventTriggerHead.prev = NULL_PTR;

      Edch_EventTriggerEnd = &Edch_EventTriggerHead;

      Rte_Exit_ExclusiveArea_0();

      /*--- Trigger Burst Mode ---*/
      Edch_SendCyclic_ctrl.burstMode = TRUE;
      Edch_SendCyclic_ctrl.burstImmeIdx = 0U;
      Edch_SendCyclic_ctrl.wait = EDCH_WAIT_500MS_IN_SENDCYCLIC;
    }

    /* Replace the old value of the signal with the current */
    SigObdReset = SigObdResetNew;
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_315, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_CLEARERRORMEM, EDCH_E_INIT);
  }
#endif
}
/* PRQA S 5203 L:Edch_ClearErrorMem_End */

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_125, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CodingStartNotification
 *
 * This callback function is called by the Coding module
 * to notify about the start of a coding process.
 * The function thereupon reset the values resp. the calculation state of
 * the CAL-ID, CVN, reference coding CVN and sub coding CVN.
 * Additional write the reseted checksum values non volatile to the NvM.
 *
 * \global Edch_Initialized
 * \global Edch_CalIdState
 * \global Edch_CalId_val
 * \global Edch_CvnState
 * \global Edch_SubCodCvnState
 * \global Edch_RefCodCvnState
 * \global Edch_RefCodCvn_val
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists
 *          if OBD relevant coding switches are configured.
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CodingStartNotification
(
  void
)
{
  /* !LINKSTO EDCH_331, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_126, 1
     */
    Edch_CalIdState = EDCH_CRC_READY;

    /* !LINKSTO EDCH_237, 1
     */
    Edch_CalId_val = EDCH_CALID_DEFAULT_VAL;
    Edch_Crc2Pdu(Edch_CalId_val, EDCH_IMME_CALID);

    /* A WriteBlock-call only return value != E_OK, if:
     * - NvM is not initialized,
     * - no permanent RAM block is defined,
     * - request for actual "BlockId" is still pending,
     * - (immediate/standard) request queue is full or
     * - data is write protected
     * All that can be checked and negated during integration phase
     * (DET-entries)
     */
    (void)Rte_Call_NvMBlock_CalId_WriteBlock(NULL_PTR);

    /* !LINKSTO EDCH_127, 1
     */
    Edch_CvnState = EDCH_CRC_READY;

    /* !LINKSTO EDCH_369, 1
     */
    Edch_Cvn_val = EDCH_CALID_DEFAULT_VAL;
    Edch_Crc2Pdu(Edch_Cvn_val, EDCH_IMME_CVN);

    /* !LINKSTO EDCH_128, 1
     */
    Edch_SubCodCvnState = EDCH_CRC_WAIT4COD;

    /* !LINKSTO EDCH_154, 1
     */
    Edch_RefCodCvnState = EDCH_CRC_WAIT4COD;

    /* !LINKSTO EDCH_269, 1
     */
    Edch_RefCodCvn_val = EDCH_CALID_DEFAULT_VAL;

    /* A WriteBlock-call only return value != E_OK, if:
     * - NvM is not initialized,
     * - no permanent RAM block is defined,
     * - request for actual "BlockId" is still pending,
     * - (immediate/standard) request queue is full or
     * - data is write protected
     * All that can be checked and negated during integration phase
     * (DET-entries)
     */
    (void)Rte_Call_NvMBlock_ReferenceCvn_Coding_WriteBlock(NULL_PTR);
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_317, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_CODINGSTARTNOTIFICATION, EDCH_E_INIT);
  }
#endif
}

/* !LINKSTO EDCH_129, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CodingEndNotification
 *
 * This callback function is called by the Coding module
 * to notify about the end of a coding process.
 * The function thereupon reset the calculation state of
 * reference coding CVN and sub coding CVN.
 * If the coding process was not successful (dataStatus!=CODING_DATA_CODED),
 * the reference coding CVN is marked as invalid
 *
 * \global Edch_Initialized
 * \global Edch_SubCodCvnState
 * \global Edch_RefCodCvnState
 *
 * \param[in] dataStatus Informs about the result of the coding process.
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists
 *          if OBD relevant coding switches are configured.
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CodingEndNotification
(
  Coding_DataStatusType dataStatus
)
{
  /* !LINKSTO EDCH_332, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_225, 1
     */
    Edch_SubCodCvnState = EDCH_CRC_READY;

    /* !LINKSTO EDCH_238, 1
     */
    if(dataStatus == CODING_DATA_CODED)
    {
      Edch_RefCodCvnState = EDCH_CRC_READY;
    }
    /* !LINKSTO EDCH_270, 1
     */
    else
    {
      Edch_RefCodCvnState = EDCH_CRC_INVALID;
    }
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_318, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_CODINGENDNOTIFICATION, EDCH_E_INIT);
  }
#endif
}

/* !LINKSTO EDCH_185, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CodingReceive
 *
 * This callback function is called by the Coding module
 * via the Receive operation of the Interface_CbkBlock interface, and receives
 * the coding data requested by a call of the corresponding Request.
 * The function thereupon readout the data of all configured OBD relevant
 * coding switches resides in this block, and prepare a checksum table
 * for calculation reference and sub coding CVN.
 *
 * \global Edch_Initialized
 * \global CodingChecksumTable
 * \global Edch_CountOfRequestedCodingBlocks
 *
 * \param[in] blockId Identifier of the Coding block.
 * \param[in] blockData Data of the Coding block.
 * \param[in] blockSize Size of the Coding block.
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists
 *          if OBD relevant coding switches are configured.
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CodingReceive
(
  Coding_BlockIdType blockId,
#ifdef RTE_PTR2ARRAYBASETYPE_PASSING
  P2VAR(UInt8, AUTOMATIC, EDCH_APPL_DATA) blockData,
#else
  P2VAR(Coding_BlockDataType, AUTOMATIC, EDCH_APPL_DATA) blockData,
#endif
  UInt8 blockSize
)
{
  uint16_least codSwitchIdx;
  uint8_least codSwitchDataIdx;

  /* !LINKSTO EDCH_340, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_018, 1
     */
    /* !LINKSTO EDCH_186, 1
     */
    for(codSwitchIdx=0U;codSwitchIdx<EDCH_CODINGSW_CNT;codSwitchIdx++)
    {
      if(Edch_CodingReceive_CodingSwitch[codSwitchIdx].blockId == blockId)
      {
        /* !LINKSTO EDCH_300, 1
         */
        /* !LINKSTO EDCH_301, 1
         */
        if((Edch_CodingReceive_CodingSwitch[codSwitchIdx].startByte + 
            Edch_CodingReceive_CodingSwitch[codSwitchIdx].len
           ) > blockSize
          )
        {
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
          /* The following Rte-call only returns value E_OK */
          (void)Rte_Call_DetServicePort_ReportError(EDCH_INSTANCE_ID,
                                                    EDCH_SID_CODINGRECEIVE,
                                                    EDCH_E_CODINGBLOCK
                                                   );
#endif
        }
        else
        {
          for(codSwitchDataIdx=0U;
              codSwitchDataIdx<Edch_CodingReceive_CodingSwitch[codSwitchIdx].len;
              codSwitchDataIdx++
             )
          {
            uint8 codByte;

#ifdef RTE_PTR2ARRAYBASETYPE_PASSING
            codByte = blockData[ Edch_CodingReceive_CodingSwitch[codSwitchIdx].startByte +
                                 codSwitchDataIdx
                               ];
#else
            codByte = (*blockData)[ Edch_CodingReceive_CodingSwitch[codSwitchIdx].startByte + 
                                    codSwitchDataIdx
                                  ];
#endif
            CodingChecksumTable[ Edch_CodingReceive_CodingSwitch[codSwitchIdx].tablePos +
                                 codSwitchDataIdx
                               ] =
                         (uint8)(codByte & Edch_CodingReceive_CodingSwitch[codSwitchIdx].mask)
                                      >> Edch_CodingReceive_CodingSwitch[codSwitchIdx].rShift;
          }
        }
      }
    }
    /* !LINKSTO EDCH_248, 1
     */
    Edch_CountOfRequestedCodingBlocks--;
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_326, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
              (EDCH_INSTANCE_ID, EDCH_SID_CODINGRECEIVE, EDCH_E_INIT);
  }
#endif
}

#endif

/* !LINKSTO EDCH_157, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_Main
 *
 * This callback function is called cyclical to check the state of the
 * calculation of CAL-ID and CVN and if necessary iniitate their calculation.
 *
 * \global Edch_Initialized
 * \global Edch_CalIdState
 * \global Edch_CvnState
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_Main
(
  void
)
{
  /* !LINKSTO EDCH_335, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_158, 1
    }
     */
    if(Edch_CalIdState == EDCH_CRC_READY)
    {
      Edch_CalculateCalId();
    }
    /* !LINKSTO EDCH_159, 1
     */
    if(Edch_CvnState == EDCH_CRC_READY)
    {
      Edch_CalculateCvn();
    }
  }
}

/* !LINKSTO EDCH_160, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCalId
 *
 * This function calculates the CAL-ID. Read all pre-calculated reference CVN
 * from the configured CVN definition blocks and write it to a checksum table. 
 * If OBD relevant coding switches exists, the refernce coding CVN also used.
 * The function check the calculation state of reference CVN, and 
 * if necassery triggers its asynchron calculation.
 * After calculation  update the calculation state and
 * write the CAL-ID non volatile using the NvM.
 *
 * \global Edch_Initialized
 * \global Edch_CalIdState
 * \global Edch_RefCodCvnState
 * \global Edch_CalId_val
 * \global Edch_CalculateCodingCvn_local
 * \global Edch_CalIdChecksumTable
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CalculateCalId
(
  void
)
{
  Edch_CvnTableCntType cvnTableIdx;
  boolean endImmediately = FALSE;

  /* !LINKSTO EDCH_336, 2
   */
  if(Edch_Initialized == TRUE)
  {
#if (EDCH_CODINGSW_CNT != 0U)
    if(Edch_CalculateCodingCvn_local.synchflag != EDCH_CALCODCVN_NO)
    {
      endImmediately = TRUE;
    }
    else
    {
      switch(Edch_RefCodCvnState)
      {
        /* !LINKSTO EDCH_161, 1
         */
        case EDCH_CRC_WAIT4COD:
        case EDCH_CRC_CALC:
          endImmediately = TRUE;
          break;

        /* !LINKSTO EDCH_271, 2
         */
        case EDCH_CRC_INVALID:
          Edch_CalIdState = EDCH_CRC_INVALID;
          Edch_CalId_val = EDCH_CALID_DEFAULT_VAL;
          Edch_Crc2Pdu(Edch_CalId_val, EDCH_IMME_CALID);
          endImmediately = TRUE;
          break;

        /* !LINKSTO EDCH_162, 1
         */
        case EDCH_CRC_READY:
          Edch_RefCodCvnState = EDCH_CRC_CALC;
          Edch_CalculateCodingCvn_local.synchflag = EDCH_CALCODCVN_REF;
          endImmediately = TRUE;
          break;

        default:
          endImmediately = FALSE;
          break;
      }
    }
#endif

    if(endImmediately == FALSE)
    {
      /* !LINKSTO EDCH_163, 1
       */
      /* !LINKSTO EDCH_165, 1
       */
      /* !LINKSTO EDCH_026, 1
       */
      for(cvnTableIdx=0U;cvnTableIdx<EDCH_CVNTABLE_CNT;cvnTableIdx++)
      {
        Edch_CalIdChecksumTable[(cvnTableIdx * 4U)+0U] =
                   EDCH_GET_HIHI_BYTE((Edch_CvnTable_Ptr[cvnTableIdx])->refCvn);
        Edch_CalIdChecksumTable[(cvnTableIdx * 4U)+1U] =
                   EDCH_GET_HILO_BYTE((Edch_CvnTable_Ptr[cvnTableIdx])->refCvn);
        Edch_CalIdChecksumTable[(cvnTableIdx * 4U)+2U] =
                   EDCH_GET_LOHI_BYTE((Edch_CvnTable_Ptr[cvnTableIdx])->refCvn);
        Edch_CalIdChecksumTable[(cvnTableIdx * 4U)+3U] =
                   EDCH_GET_LOLO_BYTE((Edch_CvnTable_Ptr[cvnTableIdx])->refCvn);
      }

#if (EDCH_CODINGSW_CNT != 0U)
      /* !LINKSTO EDCH_164, 1
       */
      /* !LINKSTO EDCH_165, 1
       */
      Edch_CalIdChecksumTable[(cvnTableIdx * 4U) + 0U] =
                                         EDCH_GET_HIHI_BYTE(Edch_RefCodCvn_val);
      Edch_CalIdChecksumTable[(cvnTableIdx * 4U) + 1U] =
                                         EDCH_GET_HILO_BYTE(Edch_RefCodCvn_val);
      Edch_CalIdChecksumTable[(cvnTableIdx * 4U) + 2U] =
                                         EDCH_GET_LOHI_BYTE(Edch_RefCodCvn_val);
      Edch_CalIdChecksumTable[(cvnTableIdx * 4U) + 3U] =
                                         EDCH_GET_LOLO_BYTE(Edch_RefCodCvn_val);
#endif

      /* !LINKSTO EDCH_166, 1
       */
      Edch_CalId_val = Crc_CalculateCRC32(Edch_CalIdChecksumTable,
                                           EDCH_CHECKSUMTABLE_SIZE,
                                           EDCH_CRC32_CALIDCVN_INITVAL
                                          );

      /* !LINKSTO EDCH_272, 1
       */
      Edch_CalIdState = EDCH_CRC_VALID;

      /* !LINKSTO EDCH_243, 1
       */
      /* A WriteBlock-call only return value != E_OK, if:
       * - NvM is not initialized,
       * - no permanent RAM block is defined,
       * - request for actual "BlockId" is still pending,
       * - (immediate/standard) request queue is full or
       * - data is write protected
       * All that can be checked and negated during integration phase
       * (DET-entries)
       */
      (void)Rte_Call_NvMBlock_CalId_WriteBlock(NULL_PTR);

      /* !LINKSTO EDCH_167, 1
       */
      Edch_Crc2Pdu(Edch_CalId_val, EDCH_IMME_CALID);
    }
  }
}

/* !LINKSTO EDCH_168, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCvn
 *
 * This function calculates the CVN. It checks the calculation state of
 * the sub CVN and of exists the sub coding CVN, and if necassery
 * triggers its asynchron calculation.
 * All calculated sub CVN, and, if OBD relevant coding switches exists,
 * the sub coding CVN are written in a checksum table. 
 * After calculation  update the calculation state and
 * write the CVN non volatile using the NvM.
 *
 * \global Edch_Initialized
 * \global Edch_CvnState
 * \global Edch_SubCvnState
 * \global Edch_SubCodCvnState
 * \global Edch_Cvn_val
 * \global Edch_CalculateSubCvn_local
 * \global Edch_CalculateCodingCvn_local
 * \global Edch_CvnChecksumTable
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CalculateCvn
(
  void
)
{
  Edch_CvnTableCntType cvnTableIdx;
  boolean endImmediately = FALSE;

  /* !LINKSTO EDCH_337, 2
   */
  if(Edch_Initialized == TRUE)
  {
#if (EDCH_CODINGSW_CNT != 0U)
      /* !LINKSTO EDCH_169, 1
       */
    if((Edch_SubCodCvnState == EDCH_CRC_CALC) ||
       (Edch_SubCodCvnState == EDCH_CRC_WAIT4COD) ||
       (Edch_CalculateCodingCvn_local.synchflag != EDCH_CALCODCVN_NO)
      )
    {
      endImmediately = TRUE;
    }
    else
    /* !LINKSTO EDCH_170, 1
     */
    {
      /* !LINKSTO EDCH_SDD_0207, 1
       */
      endImmediately = Edch_CalculateCvn_launchSubCodCvn();
    }
#endif

    /* !LINKSTO EDCH_169, 1
     */
    if(endImmediately == FALSE)
    {
      for(cvnTableIdx=0U; cvnTableIdx<EDCH_CVNTABLE_CNT; cvnTableIdx++)
      {
        if(Edch_SubCvnState[cvnTableIdx] == EDCH_CRC_CALC)
        {
          endImmediately = TRUE;
          break;
        }
      }
    }

    /* !LINKSTO EDCH_171, 1
     */
    if(endImmediately == FALSE)
    {
      /* !LINKSTO EDCH_SDD_0206, 1
       */
      endImmediately = Edch_CalculateCvn_launchSubCvn();
    }

    if(endImmediately == FALSE)
    {
      /* !LINKSTO EDCH_172, 1
       */
      for(cvnTableIdx=0U;cvnTableIdx<EDCH_CVNTABLE_CNT;cvnTableIdx++)
      {
        Edch_CvnChecksumTable[(cvnTableIdx * 4U)+0U] =
                               EDCH_GET_HIHI_BYTE(Edch_SubCvn_val[cvnTableIdx]);
        Edch_CvnChecksumTable[(cvnTableIdx * 4U)+1U] =
                               EDCH_GET_HILO_BYTE(Edch_SubCvn_val[cvnTableIdx]);
        Edch_CvnChecksumTable[(cvnTableIdx * 4U)+2U] =
                               EDCH_GET_LOHI_BYTE(Edch_SubCvn_val[cvnTableIdx]);
        Edch_CvnChecksumTable[(cvnTableIdx * 4U)+3U] =
                               EDCH_GET_LOLO_BYTE(Edch_SubCvn_val[cvnTableIdx]);
      }

#if (EDCH_CODINGSW_CNT != 0U)
      /* !LINKSTO EDCH_172, 1
       */
      Edch_CvnChecksumTable[(cvnTableIdx * 4U) + 0U] =
                                         EDCH_GET_HIHI_BYTE(Edch_SubCodCvn_val);
      Edch_CvnChecksumTable[(cvnTableIdx * 4U) + 1U] =
                                         EDCH_GET_HILO_BYTE(Edch_SubCodCvn_val);
      Edch_CvnChecksumTable[(cvnTableIdx * 4U) + 2U] =
                                         EDCH_GET_LOHI_BYTE(Edch_SubCodCvn_val);
      Edch_CvnChecksumTable[(cvnTableIdx * 4U) + 3U] =
                                         EDCH_GET_LOLO_BYTE(Edch_SubCodCvn_val);
#endif

      /* !LINKSTO EDCH_173, 1
       */
      Edch_Cvn_val = Crc_CalculateCRC32(Edch_CvnChecksumTable,
                                         EDCH_CHECKSUMTABLE_SIZE,
                                         EDCH_CRC32_CALIDCVN_INITVAL
                                        );

      /* !LINKSTO EDCH_273, 1
       */
      Edch_CvnState = EDCH_CRC_VALID;

      /* !LINKSTO EDCH_274, 1
       */
      /* A WriteBlock-call only return value != E_OK, if:
       * - NvM is not initialized,
       * - no permanent RAM block is defined,
       * - request for actual "BlockId" is still pending,
       * - (immediate/standard) request queue is full or
       * - data is write protected
       * All that can be checked and negated during integration phase
       * (DET-entries)
       */
      (void)Rte_Call_NvMBlock_Cvn_WriteBlock(NULL_PTR);

      /* !LINKSTO EDCH_174, 1
       */
      Edch_Crc2Pdu(Edch_Cvn_val, EDCH_IMME_CVN);

    }
  }
}

/* !LINKSTO EDCH_175, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCvn
 *
 * This is a wrapper function only checks if module is initialized.
 * If module is initialized call Edch_CalculateCvn_Int basic functionality.
 * In other case makes a DET entry.
 *
 * \global Edch_Initialized
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CalculateSubCvn
(
  void
)
{
  /* !LINKSTO EDCH_338, 2
   */
  if(Edch_Initialized == TRUE)
  {
    Edch_CalculateSubCvn_Int();
  }
}

#if (EDCH_CODINGSW_CNT != 0U)
/* !LINKSTO EDCH_179, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCodingCvn
 *
 * This function calculates the reference or the sub coding CVN.
 * The function is triggered cyclical and determines if and which coding CVN
 * have to be calculated.
 * The function perform the calculation accross the checksum tabel prepared by
 * Edch_CodingReceive. It processes parts of size as configured in
 * EdchCrc32CalcPartLen; In between the function ends until next triggering.
 * After calculation update the calculation state and
 * write the sub CVN non volatile using the NvM.
 *
 * \global Edch_SubCodCvnState
 * \global Edch_RefCodCvnState
 * \global Edch_SubCodCvn_val
 * \global Edch_RefCodCvn_val
 * \global Edch_CalculateCodingCvn_local
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists
 *          if OBD relevant coding switches are configured.
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(void, EDCH_APPL_CODE) Edch_CalculateCodingCvn
(
  void
)
{
  uint16_least codSwitchIdx;

  /* !LINKSTO EDCH_339, 2
   */
  if(Edch_Initialized == TRUE)
  {
    /* !LINKSTO EDCH_SDD_0208, 1
     */
    if((Edch_CalculateCodingCvn_checkStart() == TRUE))
    {
      /* Initialization
       * only first run per calculation */
      if(Edch_CalculateCodingCvn_local.codCvn_type == EDCH_CALCODCVN_NO)
      {
        Edch_CalculateCodingCvn_local.codCvn_type =
                                        Edch_CalculateCodingCvn_local.synchflag;
        /* CRC32 initial value */
        Edch_CalculateCodingCvn_local.codCvn_val =
                                        EDCH_CRC32_CODING_INITVAL ^ 0xFFFFFFFFU;

        /* !LINKSTO EDCH_246, 1
         */
        Edch_CountOfRequestedCodingBlocks = EDCH_CODING_SWITCHES_BLOCK_CNT;
        /* !LINKSTO EDCH_181, 1
         */
        for(codSwitchIdx=0U;
            codSwitchIdx<EDCH_CODING_SWITCHES_BLOCK_CNT;
            codSwitchIdx++
           )
        {
          /* The following Rte-call only returns E_OK */
          (void)Rte_Call_CodingRequest_Request(
                            Edch_CalculateCodingCvn_CodingBlockId[codSwitchIdx]
                                                   );
        }
        /* !LINKSTO EDCH_183, 1
         */

        Edch_CalculateCodingCvn_local.runLen = EDCH_CODINGSWITCH_CRCTABLELEN;
      }
      if(Edch_CountOfRequestedCodingBlocks == 0U)
      {
        uint32 calcLen;

        /* !LINKSTO EDCH_278, 1
         */
        if(Edch_CalculateCodingCvn_local.runLen < EDCHCRC32CALCPARTLEN)
        {
          calcLen = Edch_CalculateCodingCvn_local.runLen;
        }
        else
        {
          calcLen = EDCHCRC32CALCPARTLEN;
        }

        /* !LINKSTO EDCH_246, 1
         */
        Edch_CalculateCodingCvn_local.codCvn_val =
            Crc_CalculateCRC32(
                &(CodingChecksumTable[EDCH_CODINGSWITCH_CRCTABLELEN-
                                      Edch_CalculateCodingCvn_local.runLen
                                     ]
                 ),
                calcLen,
                (Edch_CalculateCodingCvn_local.codCvn_val  ^ 0xFFFFFFFFU)
                               );

        /* !LINKSTO EDCH_278, 1
         */
        Edch_CalculateCodingCvn_local.runLen -= calcLen;
        if(Edch_CalculateCodingCvn_local.runLen == 0U)
        {
          /* !LINKSTO EDCH_SDD_0208, 1
           */
          Edch_CalculateCodingCvn_cleanUp
                                     (Edch_CalculateCodingCvn_local.codCvn_val);

          /* reset to first run of calculation */
          Edch_CalculateCodingCvn_local.codCvn_type = EDCH_CALCODCVN_NO;
        }
      }
    }
    else
    {
      Edch_CalculateCodingCvn_local.synchflag = EDCH_CALCODCVN_NO;
    }
  }
}
#endif

/* !LINKSTO EDCH_305, 2
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_DataServicePort_Read
 *
 * This function is triggered by the ReadData operation of the
 * DataServices_CALID_CVN interface and writes the calculated resp.
 * the actual values of the CAL-ID and the CVN.
 *
 * \global Edch_CalIdState
 * \global Edch_CvnState
 * \global Edch_CalId_val
 * \global Edch_Cvn_val
 *
 * \param[in] --
 * \param[out] Data Buffer includes CAL-ID and CVN in appropriate manner
 *
 * \return Std_ReturnType
 * \return E_OK
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists
 *          if OBD relevant coding switches are configured.
 *
 */
/*----------------------------------------------------------------------------*/
FUNC(Std_ReturnType, EDCH_APPL_CODE) Edch_DataServicePort_Read
(
#ifdef RTE_PTR2ARRAYBASETYPE_PASSING
  P2VAR(UInt8, AUTOMATIC, EDCH_APPL_DATA) Data
#else
  P2VAR(Dcm_Data_CALID_CVN_ArrayType, AUTOMATIC, EDCH_APPL_DATA) Data
#endif
)
{
  uint8_least dataIdx;

  /* !LINKSTO EDCH_307, 1
   */
  if(Data == NULL_PTR)
  {
    /* !LINKSTO EDCH_306, 1
     */
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
        /* The following Rte-call only returns value E_OK */
        (void)Rte_Call_DetServicePort_ReportError(EDCH_INSTANCE_ID, EDCH_SID_DATASERVICEPORTREAD, EDCH_E_PARAM);
#endif
  }
  else
  {
    /* !LINKSTO EDCH_309, 1
     * !LINKSTO EDCH_355, 2
     * !LINKSTO EDCH_356, 2
     */
    /* Initialize data with default values for CAL-ID (as ASCII) and CVN */
    Dcm_Data_CALID_CVN_ArrayType CalId_Cvn_DcmVal = {
          0x3FU, 0x3FU, 0x3FU, 0x3FU, 0x3FU, 0x3FU, 0x3FU, 0x3FU,
          0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
          0x00U, 0x00U, 0x00U, 0x00U };

    /* !LINKSTO EDCH_355, 2
     * !LINKSTO EDCH_356, 2
     */
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
    if(Edch_Initialized == TRUE)
    {
#endif
    /* !LINKSTO EDCH_308, 2
     */
    if(Edch_CalId_val != EDCH_CALID_DEFAULT_VAL)
    {
      CalId_Cvn_DcmVal[0U] = HEX2ASCII((uint8)((uint8)(EDCH_GET_HIHI_BYTE(Edch_CalId_val)>>4U) & 0x0FU));
      CalId_Cvn_DcmVal[1U] = HEX2ASCII((uint8)(EDCH_GET_HIHI_BYTE(Edch_CalId_val) & 0x0FU));
      CalId_Cvn_DcmVal[2U] = HEX2ASCII((uint8)((uint8)(EDCH_GET_HILO_BYTE(Edch_CalId_val)>>4U) & 0x0FU));
      CalId_Cvn_DcmVal[3U] = HEX2ASCII((uint8)(EDCH_GET_HILO_BYTE(Edch_CalId_val) & 0x0FU));
      CalId_Cvn_DcmVal[4U] = HEX2ASCII((uint8)((uint8)(EDCH_GET_LOHI_BYTE(Edch_CalId_val)>>4U) & 0x0FU));
      CalId_Cvn_DcmVal[5U] = HEX2ASCII((uint8)(EDCH_GET_LOHI_BYTE(Edch_CalId_val) & 0x0FU));
      CalId_Cvn_DcmVal[6U] = HEX2ASCII((uint8)((uint8)(EDCH_GET_LOLO_BYTE(Edch_CalId_val)>>4U) & 0x0FU));
      CalId_Cvn_DcmVal[7U] = HEX2ASCII((uint8)(EDCH_GET_LOLO_BYTE(Edch_CalId_val) & 0x0FU));
    }

    /* !LINKSTO EDCH_310, 2
     */
    if(Edch_Cvn_val != EDCH_CALID_DEFAULT_VAL)
    {
      CalId_Cvn_DcmVal[16U] = EDCH_GET_HIHI_BYTE(Edch_Cvn_val);
      CalId_Cvn_DcmVal[17U] = EDCH_GET_HILO_BYTE(Edch_Cvn_val);
      CalId_Cvn_DcmVal[18U] = EDCH_GET_LOHI_BYTE(Edch_Cvn_val);
      CalId_Cvn_DcmVal[19U] = EDCH_GET_LOLO_BYTE(Edch_Cvn_val);
    }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    
    for(dataIdx=0U;dataIdx<sizeof(Dcm_Data_CALID_CVN_ArrayType);dataIdx++)
    {

#ifdef RTE_PTR2ARRAYBASETYPE_PASSING
      Data[dataIdx] = (UInt8)CalId_Cvn_DcmVal[dataIdx];
#else
      (*Data)[dataIdx] = CalId_Cvn_DcmVal[dataIdx];
#endif
    }
  }

  return E_OK;
}


#define EDCH_STOP_SEC_APPL_CODE
#include "MemMap.h"

/*==================[internal function definitions]===========================*/

#define EDCH_START_SEC_CODE
#include "MemMap.h"

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_Init_First
 *
 * Helper function for Edch_Init
 *
 * \global Edch_SubCvnState
 * \global Edch_SubCodCvnState
 * \global Edch_CalIdState
 * \global Edch_CvnState
 * \global Edch_RefCodCvnState
 * \global Edch_CalId_val
 * \global Edch_Cvn_val
 * \global Edch_RefCodCvn_val
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC( void, EDCH_CODE ) Edch_Init_First
(
  void
)
{
  /* !LINKSTO EDCH_063, 1
   */
  if(Rte_Call_FirstStartPort_GetFirstStart() == E_OK)
  {

    /* !LINKSTO EDCH_228, 1
     */
    Edch_CalId_val = EDCH_CALID_DEFAULT_VAL;

    /* A WriteBlock-call only return value != E_OK, if:
     * - NvM is not initialized,
     * - no permanent RAM block is defined,
     * - request for actual "BlockId" is still pending,
     * - (immediate/standard) request queue is full or
     * - data is write protected
     * All that can be checked and negated during integration phase
     * (DET-entries)
     */
    (void)Rte_Call_NvMBlock_CalId_WriteBlock(NULL_PTR);

    /* !LINKSTO EDCH_229, 1
     */
    Edch_Cvn_val = EDCH_CALID_DEFAULT_VAL;

    /* A WriteBlock-call only return value != E_OK, if:
     * - NvM is not initialized,
     * - no permanent RAM block is defined,
     * - request for actual "BlockId" is still pending,
     * - (immediate/standard) request queue is full or
     * - data is write protected
     * All that can be checked and negated during integration phase
     * (DET-entries)
     */
    (void)Rte_Call_NvMBlock_Cvn_WriteBlock(NULL_PTR);
    Edch_Crc2Pdu(Edch_Cvn_val, EDCH_IMME_CVN);

#if (EDCH_CODINGSW_CNT != 0U)
    /* !LINKSTO EDCH_260, 1
     */
    Edch_RefCodCvn_val = EDCH_CALID_DEFAULT_VAL;

    /* A WriteBlock-call only return value != E_OK, if:
     * - NvM is not initialized,
     * - no permanent RAM block is defined,
     * - request for actual "BlockId" is still pending,
     * - (immediate/standard) request queue is full or
     * - data is write protected
     * All that can be checked and negated during integration phase
     * (DET-entries)
     */
    (void)Rte_Call_NvMBlock_ReferenceCvn_Coding_WriteBlock(NULL_PTR);
#endif
  }


}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_Init_SendData
 *
 * Helper function for Edch_Init.
 * Initializes data and states concerning cyclical communication with OBD Host.
 *
 * \global Edch_sendIpduData
 * \global Edch_Diagnostics_OccCnt
 * \global Edch_SendCyclic_ctrl
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC( void, EDCH_CODE ) Edch_Init_SendData
(
  void
)
{
  uint16_least diagIdx;
  uint8_least muxmax;
  uint8_least ipduDataIdx;

  /* pre-initialize all send data */
  /* !LINKSTO EDCH_062, 1
   */
  for(muxmax=0U;muxmax<=EDCH_MUX_MAX;muxmax++)
  {
    for(ipduDataIdx=0U;
        ipduDataIdx<sizeof(DIAG_OBD_DATA_Type);
        ipduDataIdx++
       )
    {
      Edch_sendIpduData[muxmax].IpduData[ipduDataIdx] = 0U;
    }
  }

 /* initialize send data of all configured diagnostics */
  for(diagIdx=0U;diagIdx<EDCH_DIAGNOSTICS_COUNT;diagIdx++)
  {
    if(Edch_Diagnostics_Continuous[diagIdx]==TRUE)
    {
      /* !LINKSTO EDCH_061, 2
       */
      EDCH_SET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_ACTIVE_BITORDER);
    }
    else
    {
      /* !LINKSTO EDCH_066, 1
       */
      Edch_Diagnostics_OccCnt[diagIdx] = 0U;
    }
    
    /* !LINKSTO EDCH_368, 1
     */
    if(Edch_Diagnostics_Monitor_EN_Stat[diagIdx]==FALSE)
    {
      EDCH_SET_DIAGIDX_FLAGORDER(diagIdx,EDCH_MONITOR_ENABLED_STATUS_BITORDER);
    }
  }

  /* initialize MUX_MAX signal */
  /* !LINKSTO EDCH_208, 1
   */
  /* The following Rte-call only returns value != E_OK,
   * if the COM service is not available.
   * This should be checked and negated during integration phase.
   */
  (void)Rte_Write_ST_DIAG_OBD_MUX_MAX((UInt6)EDCH_MUX_MAX);

  /* !LINKSTO EDCH_284, 1
   */
  Edch_SendCyclic_ctrl.aliveCnt = 0U;

}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic_PrepareOccurrenceTimer
 *
 * Helper function for Edch_SendCyclic.
 * Check if periodicaly report of non continuous diasnostic status is in time.
 * If not prepare event triggered send for corresponding diagnostic.
 *
 * \global Edch_Diagnostics_OccCnt
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerEnd
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC( void, EDCH_CODE ) Edch_SendCyclic_PrepareOccurrenceTimer
(
  void
)
{
  Edch_EventIdxType diagIdx;

  /* !LINKSTO EDCH_139, 1
   */
  /* !LINKSTO EDCH_242, 1
   */
  for(diagIdx=0U;diagIdx<EDCH_DIAGNOSTICS_COUNT;diagIdx++)
  {
    /* !LINKSTO EDCH_139, 1
     */
    /* !LINKSTO EDCH_242, 1
     */
    if(Edch_Diagnostics_Continuous[diagIdx]==FALSE)
    {
      if(Edch_Diagnostics_OccCnt[diagIdx] > 0U)
      {
        /* !LINKSTO EDCH_139, 1
         */
        --(Edch_Diagnostics_OccCnt[diagIdx]);

        /* ExclusiveArea used to guard concurency access to
         * Edch_EventTriggerList and Edch_EventTriggerEnd */
        Rte_Enter_ExclusiveArea_0();
        if(Edch_Diagnostics_OccCnt[diagIdx] == 0U)
        {
          /* !LINKSTO EDCH_242, 1
           */
          if(Edch_EventTriggerList[diagIdx].marker == EDCH_REPORT_NOT)
          {
            Edch_EventTriggerEnd->next = &Edch_EventTriggerList[diagIdx];
            Edch_EventTriggerList[diagIdx].prev = Edch_EventTriggerEnd;
            Edch_EventTriggerEnd = &Edch_EventTriggerList[diagIdx];
            Edch_EventTriggerEnd->next = NULL_PTR;
            Edch_EventTriggerEnd->marker = EDCH_REPORT_PRE;
          }
        }
        Rte_Exit_ExclusiveArea_0();
      }
    }
  }

}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic_BurstMode
 *
 * Helper function for Edch_SendCyclic. Called for send in burst mode.
 * Perform send of next part of the multiplexed message to OBD Host.
 * If necesssary update data in respect to EDCH_TEST_ACTIVE.
 * After last part prepare for regular cyclical send.
 *
 * \global Edch_SendCyclic_ctrl
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerHead
 * \global Edch_EventTriggerEnd
 * \global Edch_sendIpduData
 * \global Edch_CalIdState
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_BurstMode
(
  void
)
{
  const uint8 Edch_BurstIMME =
                         Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.burstImmeIdx];
  Edch_EventStatusIpduDataType defaultCALID = {EDCH_CALID_DEFAULT_DATA};

  /* !LINKSTO EDCH_084, 1
   */
  /* Range of Edch_SendCyclic_ctrl.aliveCnt is 0x00U to 0x0EU */
  Edch_SendCyclic_ctrl.aliveCnt = (Edch_SendCyclic_ctrl.aliveCnt + 1U) % 0x0FU;

  /* !LINKSTO EDCH_085, 1
   */
  /* The following Rte-call only returns value != E_OK,
   * if the COM service is not available.
   * This should be checked and negated during integration phase.
   */
  (void)Rte_Write_ST_DIAG_OBD_ALIVE((UInt4)Edch_SendCyclic_ctrl.aliveCnt);

  if(Edch_BurstIMME >= EDCH_IMME_DATA_LOW)
  {
    /* !LINKSTO EDCH_141, 2
     */
    const Edch_Diagnostics_NumType minErrNum =
                 ((Edch_BurstIMME - EDCH_IMME_DATA_LOW) * EDCH_DIAG2IMME) + 1U;
    const Edch_Diagnostics_NumType maxErrNum = (minErrNum + (EDCH_DIAG2IMME)) - 1U;
    Edch_EventTriggerListPtrType listPtr;

    for(listPtr = EDCH_EVENTTRIGGERLIST_HEAD;
                                    listPtr != NULL_PTR;listPtr = listPtr->next)
    {
      const Edch_EventIdxType diagIdx = listPtr->idx;
      if((Edch_Diagnostics_Number[diagIdx] >= minErrNum) &&
         (Edch_Diagnostics_Number[diagIdx] <= maxErrNum) &&
         (Edch_Diagnostics_Continuous[diagIdx]==FALSE)
        )
      {
        if(Edch_Diagnostics_OccCnt[diagIdx] == 0U)
        {
          EDCH_RESET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_ACTIVE_BITORDER);
        }
        else
        {
          EDCH_SET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_ACTIVE_BITORDER);
        }
      }
    }
  }

  /* !LINKSTO EDCH_032, 1
   * !LINKSTO EDCH_037, 1
   */
  if(((Edch_BurstIMME == EDCH_IMME_CALID)&&(Edch_CalId_val == EDCH_CALID_DEFAULT_VAL))
     || ((Edch_BurstIMME == EDCH_IMME_CVN)&&(Edch_Cvn_val == EDCH_CALID_DEFAULT_VAL))
	) 
  {
    /* The following Rte-call only returns value != E_OK,
     * if the COM service is not available.
     * This should be checked and negated during integration phase.
     */
    (void)Rte_Write_ST_DIAG_OBD_DATA(&defaultCALID);
  }
  else
  {
    /* !LINKSTO EDCH_087, 1
     */
    /* The following Rte-call only returns value != E_OK,
     * if the COM service is not available.
     * This should be checked and negated during integration phase.
     */
    (void)Rte_Write_ST_DIAG_OBD_DATA
                          (&(Edch_sendIpduData[Edch_BurstIMME]));
  }
  Edch_SendCyclic_ctrl.lastImme = (UInt6)Edch_BurstIMME;
  
  /* !LINKSTO EDCH_088, 1
   * !LINKSTO EDCH_349, 2
   */
  Edch_SendCyclic_ctrl.lastSendError = Rte_Write_ST_DIAG_OBD_MUX_IMME((UInt6)Edch_BurstIMME);

  /* !LINKSTO EDCH_089, 1
   */
  ++Edch_SendCyclic_ctrl.burstImmeIdx;
  if(Edch_SendCyclic_ctrl.burstImmeIdx >= EDCH_DIAGNOSTICS_IMME_CNT)
  {
    Edch_SendCyclic_ctrl.burstImmeIdx = 0U;
    /* !LINKSTO EDCH_090, 1
     */
    Edch_SendCyclic_ctrl.burstMode = FALSE;
    /* !LINKSTO EDCH_091, 1
     */
    Edch_SendCyclic_ctrl.cyclicalImmeIdx = 0U;
    Edch_SendCyclic_ctrl.cycleTimer = 0x00U;
  }
}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic_EventTriggeredMode
 *
 * Helper function for Edch_SendCyclic.
 * Called for send in event triggered mode.
 * Perform send for this part of the multiplexed message to OBD Host,
 * which contains the reference diagnostic
 * (first diagnostic whose state changed and are not yet sended).
 * If necesssary update data in respect to EDCH_TEST_ACTIVE.
 *
 * \global Edch_sendIpduData
 * \global Edch_SendCyclic_ctrl
 *
 * \param[in] refDiagIdx Index of reference event
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_EventTriggeredMode
(
  Edch_EventIdxType refDiagIdx
)
{
  Edch_EventIdxType diagIdx;
  Edch_EventTriggerListPtrType listPtr;  
  const uint16 refErrNum = Edch_Diagnostics_Number[refDiagIdx];
  const uint16 minErrNum = (((refErrNum - 1U)/EDCH_DIAG2IMME) * EDCH_DIAG2IMME) + 1U;
  const uint16 maxErrNum = (minErrNum + (EDCH_DIAG2IMME)) - 1U;
  /* !LINKSTO EDCH_265, 1
   */
  const UInt6 imme = ((refErrNum - 1U) / EDCH_DIAG2IMME) + EDCH_IMME_DATA_LOW;

  if(Edch_SendCyclic_ctrl.cycleTimer == 0x00U)
  {
    /* !LINKSTO EDCH_095, 1
     */
    if(imme != Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx])
    {
      Edch_SendCyclic_ctrl.cyclicalDelayed = TRUE;
    }
    else
    /* !LINKSTO EDCH_293, 1
     */
    {
      ++Edch_SendCyclic_ctrl.cyclicalImmeIdx;
      Edch_SendCyclic_ctrl.cyclicalImmeIdx %= EDCH_DIAGNOSTICS_IMME_CNT;
    }
  }

  for(listPtr = EDCH_EVENTTRIGGERLIST_HEAD;
                                    listPtr != NULL_PTR;listPtr = listPtr->next)
  {
    /* !LINKSTO EDCH_100, 1
     */
    diagIdx = listPtr->idx;
    if( (Edch_Diagnostics_Number[diagIdx] >= minErrNum) &&
        (Edch_Diagnostics_Number[diagIdx] <= maxErrNum)
      )
    {
      Edch_SendCyclic_moreEventTriggeredMode(diagIdx);
    }
  }
  /* !LINKSTO EDCH_101, 1
   */
  /* The following Rte-call only returns value != E_OK,
   * if the COM service is not available.
   * This should be checked and negated during integration phase.
   */
  (void)Rte_Write_ST_DIAG_OBD_DATA(&(Edch_sendIpduData[imme]));

  Edch_SendCyclic_ctrl.lastImme = imme;
  
  /* !LINKSTO EDCH_102, 1
   * !LINKSTO EDCH_349, 2
   */
  Edch_SendCyclic_ctrl.lastSendError = Rte_Write_ST_DIAG_OBD_MUX_IMME(imme);
}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic_moreEventTriggeredMode
 *
 * Helper function for Edch_SendCyclic resp Edch_SendCyclic_EventTriggeredMode.
 * Called for send in event triggered mode.
 * Update ST_DIAG_OBD_DATA of the multiplexed message to OBD Host,
 * for given event.
 *
 * \global Edch_sendIpduData
 * \global Edch_EventTriggerList
 * \global Edch_Diagnostics_OccCnt
 *
 * \param[in] diagIdx Index of event to process
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_SendCyclic_moreEventTriggeredMode
(
    Edch_EventIdxType diagIdx

)
{
  switch(Edch_EventTriggerList[diagIdx].marker)
  {
    /* !LINKSTO EDCH_096, 1
     */
    case EDCH_REPORT_HEAL:
      EDCH_RESET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_FAILED_CURR_BITORDER);
      Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
      break;

    /* !LINKSTO EDCH_097, 1
     */
    /* !LINKSTO EDCH_098, 1
     */
    case EDCH_REPORT_FAIL:
      if((EDCH_GET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_FAILED_CURR_BITORDER))
          != 0x00U
        )
      /* !LINKSTO EDCH_097, 1
       */
      {
        Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
      }
      else
      /* !LINKSTO EDCH_098, 1
       */
      {
        EDCH_SET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_FAILED_CURR_BITORDER);
        Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_HEAL;
      }
      break;

    /* !LINKSTO EDCH_099, 1
     */
    case EDCH_REPORT:
    case EDCH_REPORT_PRE:
    default: /* prevent compiler warning and MISRA deviation */
      Edch_EventTriggerList[diagIdx].marker = EDCH_REPORT_NOT;
      break;
  }

  /* !LINKSTO EDCH_142, 2
   */
  if(Edch_Diagnostics_Continuous[diagIdx]==FALSE)
  {
    if(Edch_Diagnostics_OccCnt[diagIdx] == 0U)
    {
      EDCH_RESET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_ACTIVE_BITORDER);
    }
    else
    {
      EDCH_SET_DIAGIDX_FLAGORDER(diagIdx,EDCH_TEST_ACTIVE_BITORDER);
    }
  }

  if(Edch_EventTriggerList[diagIdx].marker == EDCH_REPORT_NOT)
  {
    /* ExclusiveArea used to guard concurency access to
     * Edch_EventTriggerList and Edch_EventTriggerEnd */
    Rte_Enter_ExclusiveArea_0();
    Edch_RemoveFromEventList(diagIdx);
    Rte_Exit_ExclusiveArea_0();
  }
}

/* !LINKSTO EDCH_SDD_0024, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_SendCyclic_CyclicalMode
 *
 * Helper function for Edch_SendCyclic. Called for send in cyclical mode.
 * Perform send of next part of the multiplexed message to OBD Host.
 *
 * \global Edch_SendCyclic_ctrl
 * \global Edch_CalIdState
 * \global Edch_sendIpduData
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE)Edch_SendCyclic_CyclicalMode
(
  void
)
{
  Edch_EventStatusIpduDataType DefaultCalId = {EDCH_CALID_DEFAULT_DATA};

  /* !LINKSTO EDCH_105, 1
   */
  Edch_SendCyclic_ctrl.cyclicalDelayed = FALSE;

  /* !LINKSTO EDCH_032, 1
   * !LINKSTO EDCH_037, 1
   */
  if(((Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx] ==
       EDCH_IMME_CALID
      ) && (Edch_CalId_val == EDCH_CALID_DEFAULT_VAL)
     ) ||
	 ((Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx] ==
       EDCH_IMME_CVN
      ) && (Edch_Cvn_val == EDCH_CALID_DEFAULT_VAL)
     )
	)
  {
    /* The following Rte-call only returns value != E_OK,
     * if the COM service is not available.
     * This should be checked and negated during integration phase.
     */
    (void)Rte_Write_ST_DIAG_OBD_DATA(&DefaultCalId);
  }
  else
  {
    /* !LINKSTO EDCH_106, 1
     */
    /* The following Rte-call only returns value != E_OK,
     * if the COM service is not available.
     * This should be checked and negated during integration phase.
     */
    (void)Rte_Write_ST_DIAG_OBD_DATA
     (&(Edch_sendIpduData[Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx]]));
  }

  Edch_SendCyclic_ctrl.lastImme =
        (UInt6)Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx];
  /* !LINKSTO EDCH_107, 1
   * !LINKSTO EDCH_349, 2
   */
  Edch_SendCyclic_ctrl.lastSendError = Rte_Write_ST_DIAG_OBD_MUX_IMME
                    ((UInt6)Edch_SendOrder_IMME[Edch_SendCyclic_ctrl.cyclicalImmeIdx]);

  /* !LINKSTO EDCH_108, 1
   */
  ++Edch_SendCyclic_ctrl.cyclicalImmeIdx;
  Edch_SendCyclic_ctrl.cyclicalImmeIdx %= EDCH_DIAGNOSTICS_IMME_CNT;
}

#if (EDCH_CODINGSW_CNT != 0U)
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCvn_launchSubCodCvn
 *
 * Helper function for Edch_CalculateCvn.
 * Called for initiate the asynchron calculation of sub coding CVN.
 *
 * \global Edch_SubCodCvnState
 * \global Edch_CalculateCodingCvn_local
 *
 * \param[in] --
 * \param[out] --
 *
 * \return boolean
 * \retval TRUE If asynchron calculation of sub coding CVN is initiated.
 * \retval FALSE If no asynchron calculation is initiated,
 *               because sub coding CVN is not ready for calculation.
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCvn_launchSubCodCvn
(
  void
)
{
  boolean retval = FALSE;
  if(Edch_SubCodCvnState == EDCH_CRC_READY)
  {
    Edch_SubCodCvnState = EDCH_CRC_CALC;
    Edch_CalculateCodingCvn_local.synchflag = EDCH_CALCODCVN_SUB;
    retval = TRUE;
  }
  return retval;
}
#endif

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCvn_Int
 *
 * This function calculates a sub CVN. The function is triggered cyclical,
 * determines if and which sub CVN have to be calculated  and consult
 * the checksum table in the corresponding CVN definition block.
 * The function perform the calculation of the sub CVN in parts of size
 * as configured in EdchCrc32CalcPartLen; In between the function ends until
 * next triggering.
 * After calculation update the calculation state and
 * write the sub CVN non volatile using the NvM.
 *
 * \global Edch_SubCvnState
 * \global Edch_SubCvn_val
 * \global Edch_CalculateSubCvn_local
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_APPL_CODE) Edch_CalculateSubCvn_Int
(
  void
)
{
  /* !LINKSTO EDCH_275, 1
   */
  /* length to process this run */
  uint32   runLen_sub = EDCHCRC32CALCPARTLEN;

  
  /* !LINKSTO EDCH_287, 1
   */
  if(Edch_CalculateSubCvn_local.synchflag != EDCH_CALSUBCVN_INVALID)
  {

    /* Initialization for first run this subCVN */
    if(Edch_CalculateSubCvn_local.subCvn_idx == EDCH_CALSUBCVN_INVALID)
    {
      /* identify subCvn to calculate */
      /* !LINKSTO EDCH_176, 1
       */
      Edch_CalculateSubCvn_local.subCvn_idx =
                                           Edch_CalculateSubCvn_local.synchflag;
      /* CRC32 initial value */
      Edch_CalculateSubCvn_local.subCvn_val =
          Edch_CalculateSubCvn_CrcInit[Edch_CalculateSubCvn_local.subCvn_idx] ^
                                                                    0xFFFFFFFFU;
      /* start on first table part */
      Edch_CalculateSubCvn_local.tableIdx = 0U;
    }

    /* !LINKSTO EDCH_177, 1
     */
    /* loop through all table parts */
    while(Edch_CalculateSubCvn_local.tableIdx <
          ((uint8)(Edch_CvnTable_Ptr[Edch_CalculateSubCvn_local.subCvn_idx]->tableCnt))
         )
    {
      /* !LINKSTO EDCH_026, 1
       */
      /* Deviation MISRA-1 <+4> */ /* PRQA S 0489 4 */
      CONSTP2CONST(uint8, AUTOMATIC, EDCH_APPL_CONST) startPtr =
          *((&(Edch_CvnTable_Ptr[Edch_CalculateSubCvn_local.subCvn_idx]->tablePtr))
            + (Edch_CalculateSubCvn_local.tableIdx*2U)
           );
      /* Deviation MISRA-1 <+4> */ /* PRQA S 0489 4 */
      CONSTP2CONST(uint8, AUTOMATIC, EDCH_APPL_CONST) endPtr =
          *((&(Edch_CvnTable_Ptr[Edch_CalculateSubCvn_local.subCvn_idx]->tablePtr))
            + (Edch_CalculateSubCvn_local.tableIdx*2U) + 1U
           );


      /* ignore wrong configured block */
      /* ----- NXTR PATCH START ----- */
      /* Added By: Archana Shivarudrappa (Nxtr)
       * Date Added: 03Nov14
       *
       * Edch.c: Anomaly correction A7568
       *
       */

      if((startPtr == NULL_PTR) || (endPtr == NULL_PTR) || (endPtr <= startPtr))
      {
     /* ----- NXTR PATCH END ----- */
    	  /* !LINKSTO EDCH_299, 1
         */

#if (EDCH_DEV_ERROR_DETECT == STD_ON)
        /* The following Rte-call only returns value E_OK */
        (void)Rte_Call_DetServicePort_ReportError
                  (EDCH_INSTANCE_ID, EDCH_SID_CALCULATESUBCVN, EDCH_E_CVNTABLE);
#endif
        /* process next block */
        Edch_CalculateSubCvn_local.tableIdx++;
        /* reset count of processed bytes in next block */
        Edch_CalculateSubCvn_local.procLen = 0U;
      }
      else
      {
        /* spare length this block */
        /* Deviation MISRA-1 <+2> */ /* PRQA S 0489 2 */
        const uint32 spareLen =
                (endPtr + 1U) - (startPtr + Edch_CalculateSubCvn_local.procLen);
        /* length to calc next run */
        uint32 calcLen;
        if(spareLen < runLen_sub)
        {
          calcLen = spareLen;
        }
        else
        {
          calcLen = runLen_sub;
        }

        /* !LINKSTO EDCH_177, 1
         */
        /* Deviation MISRA-1 <+6> */ /* PRQA S 0489 6 */
        Edch_CalculateSubCvn_local.subCvn_val =
            Crc_CalculateCRC32
                        ((startPtr + Edch_CalculateSubCvn_local.procLen),
                         calcLen,
                         (Edch_CalculateSubCvn_local.subCvn_val  ^ 0xFFFFFFFFU)
                        );

        Edch_CalculateSubCvn_local.procLen += calcLen;

        /* !LINKSTO EDCH_275, 1
         */
        runLen_sub -= calcLen;

        /* Deviation MISRA-1 <+1> */ /* PRQA S 0489 1 */
        if(Edch_CalculateSubCvn_local.procLen > (uint32)(endPtr - startPtr))
        {
          /* process next block */
          Edch_CalculateSubCvn_local.tableIdx++;
          /* reset count of processed bytes in next block */
          Edch_CalculateSubCvn_local.procLen = 0U;
        }
        /* !LINKSTO EDCH_275, 1
         */
        if(runLen_sub == 0U)
        {
          break;
        }
      }
    }

    if(Edch_CalculateSubCvn_local.tableIdx >=
       (uint8)(Edch_CvnTable_Ptr[Edch_CalculateSubCvn_local.subCvn_idx]->tableCnt)
      )
    {
      /* !LINKSTO EDCH_288, 1
       */
      Edch_CalculateSubCvn_local.synchflag = EDCH_CALSUBCVN_INVALID;

      /* !LINKSTO EDCH_178, 1
       */
      Edch_SubCvn_val[Edch_CalculateSubCvn_local.subCvn_idx] =
                                          Edch_CalculateSubCvn_local.subCvn_val;
      Edch_SubCvnState[Edch_CalculateSubCvn_local.subCvn_idx] = EDCH_CRC_VALID;

      /* !LINKSTO EDCH_244, 1
       */
      Edch_Call_NvMBlock_SubCvn_WriteBlock
                                        (Edch_CalculateSubCvn_local.subCvn_idx);

      Edch_CalculateSubCvn_local.subCvn_idx = EDCH_CALSUBCVN_INVALID;
    }
  }
}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCvn_launchSubCvn
 *
 * Helper function for Edch_CalculateCvn.
 * Called for initiate the asynchron calculation of one sub CVN.
 *
 * \global Edch_SubCvnState
 * \global Edch_CalculateSubCvn_local
 *
 * \param[in] --
 * \param[out] --
 *
 * \return boolean
 * \retval TRUE If asynchron calculation is initiated
 * \retval FALSE If no asynchron calculation is initiated,
 *               because sub CVN is not ready for calculation.
 *
 * \pre --
 *
 * \post --
 *
 * \remarks -- 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCvn_launchSubCvn
(
  void
)
{
  boolean retval = FALSE;
  Edch_CvnTableCntType subCvnIdx;

  for(subCvnIdx=0U; subCvnIdx<EDCH_CVNTABLE_CNT; subCvnIdx++)
  {
    if(Edch_SubCvnState[subCvnIdx] == EDCH_CRC_READY)
    {
      Edch_SubCvnState[subCvnIdx] = EDCH_CRC_CALC;
      Edch_CalculateSubCvn_local.synchflag = subCvnIdx;
      retval = TRUE;
      break;
    }
  }

  return retval;
}

#if (EDCH_CODINGSW_CNT != 0U)

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCodingCvn_checkStart
 *
 * Helper function for Edch_CalculateCodingCvn.
 * Check whether actual requested coding CVN not allready calculating and not invalid.
 *
 * \global Edch_RefCodCvnState
 * \global Edch_SubCodCvnState
 * \global Edch_CalculateCodingCvn_local
 *
 * \param[in] --
 * \param[out] --
 *
 * \return boolean
 * \retval TRUE If are allowed to calculate coding CVN 
 * \retval FALSE If CVN is not ready for calculation, bacause invalid or allready calculating
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists if OBD relevant coding switches are configured. 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(boolean, EDCH_CODE) Edch_CalculateCodingCvn_checkStart
(
  void
)
{
  boolean retvalue = TRUE;
  Coding_DataStatusType dataStatus;

  /* !LINKSTO EDCH_245, 1
   */
  switch (Edch_CalculateCodingCvn_local.synchflag)
  {
  case EDCH_CALCODCVN_REF:
    /* !LINKSTO EDCH_180, 1
     */
    if(Edch_RefCodCvnState != EDCH_CRC_CALC)
    {
      retvalue = FALSE;
    }
    else
    {
      /* !LINKSTO EDCH_276, 1
       */
      /* The following Rte-call only returns E_OK */
      (void)Rte_Call_CodingDataStatus_Get(&dataStatus);
      /* !LINKSTO EDCH_277, 1
       */
      if(dataStatus != CODING_DATA_CODED)
      {
        Edch_RefCodCvnState = EDCH_CRC_INVALID;
        retvalue = FALSE;
      }
    }
    break;
  case EDCH_CALCODCVN_SUB:
    /* !LINKSTO EDCH_180, 1
     */
    if(Edch_SubCodCvnState != EDCH_CRC_CALC)
    {
      retvalue = FALSE;
    }
    break;
  /* !LINKSTO EDCH_289, 1
   */
  case EDCH_CALCODCVN_NO:
  default:
    retvalue = FALSE;
    break;
  }

  return retvalue;
}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CalculateCodingCvn_cleanUp
 *
 * Helper function for Edch_CalculateCodingCvn.
 * Assign actual calculated checksum to corresponding coding CVN.
 * Write coding CVN non volatile using  Nvm.
 *
 * \global Edch_RefCodCvnState
 * \global Edch_SubCodCvnState
 * \global Edch_RefCodCvn_val
 * \global Edch_SubCodCvn_val
 * \global Edch_CalculateCodingCvn_local
 *
 * \param[in] my_codCvn_val actual calculated coding CVN
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The function only exists if OBD relevant coding switches are configured. 
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_CalculateCodingCvn_cleanUp
(
    Edch_ChecksumValType my_codCvn_val
)
{
  if(Edch_CalculateCodingCvn_local.synchflag == EDCH_CALCODCVN_REF)
  {
    if(Edch_RefCodCvnState == EDCH_CRC_CALC)
    {
      /* !LINKSTO EDCH_184, 1
       */
      Edch_RefCodCvnState = EDCH_CRC_VALID;

      /* !LINKSTO EDCH_246, 1
       */
      Edch_RefCodCvn_val = my_codCvn_val;

      /* !LINKSTO EDCH_247, 1
       */
      /* A WriteBlock-call only return value != E_OK, if:
       * - NvM is not initialized,
       * - no permanent RAM block is defined,
       * - request for actual "BlockId" is still pending,
       * - (immediate/standard) request queue is full or
       * - data is write protected
       * All that can be checked and negated during integration phase
       * (DET-entries)
       */
      (void)Rte_Call_NvMBlock_ReferenceCvn_Coding_WriteBlock(NULL_PTR);
    }
  }
  if(Edch_CalculateCodingCvn_local.synchflag == EDCH_CALCODCVN_SUB)
  {
    if(Edch_SubCodCvnState == EDCH_CRC_CALC)
    {
      /* !LINKSTO EDCH_184, 1
       */
      Edch_SubCodCvnState = EDCH_CRC_VALID;

      /* !LINKSTO EDCH_246, 1
       */
      Edch_SubCodCvn_val = my_codCvn_val;
    }
  }
  /* !LINKSTO EDCH_290, 1
   */
  Edch_CalculateCodingCvn_local.synchflag = EDCH_CALCODCVN_NO;
}

#endif


/* !LINKSTO EDCH_167, 1
 */
/* !LINKSTO EDCH_174, 1
 */
/* !LINKSTO EDCH_044, 1
 */
/* !LINKSTO EDCH_214, 1
 */
/* !LINKSTO EDCH_045, 1
 */
/* !LINKSTO EDCH_215, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_Crc2Pdu
 *
 * The function writes the given checksum to the payload of a specific part of 
 * multiplexed ST_DIAG_OBD_DATA
 *
 * \global --
 *
 * \param[in] crc checksum to be writen
 * \param[in] imme IMME resp. multiplex id of ST_DIAG_OBD_DATA
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_Crc2Pdu
(
  uint32 crc,
  UInt6 imme
)
{
  Edch_sendIpduData[imme].IpduData[0U] = (UInt6)((uint8)(crc >> 0U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[1U] = (UInt6)((uint8)(crc >> 4U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[2U] = (UInt6)((uint8)(crc >> 8U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[3U] = (UInt6)((uint8)(crc >> 12U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[4U] = (UInt6)((uint8)(crc >> 16U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[5U] = (UInt6)((uint8)(crc >> 20U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[6U] = (UInt6)((uint8)(crc >> 24U) & 0xFU);
  Edch_sendIpduData[imme].IpduData[7U] = (UInt6)((uint8)(crc >> 28U) & 0xFU);
}

/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_RemoveFromEventList
 *
 * Remove given Event from event triggered mode send list.
 *
 * \global Edch_EventTriggerList
 * \global Edch_EventTriggerEnd
 *
 * \param[in] diagIdx Index of Event have to be removed
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks The call of this function
 *          shall be guarded against concurrency access on Edch_EventTriggerList
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(void, EDCH_CODE) Edch_RemoveFromEventList
(
  Edch_EventIdxType diagIdx
)
{
  Edch_EventTriggerList[diagIdx].prev->next = Edch_EventTriggerList[diagIdx].next;
  if(Edch_EventTriggerEnd == &(Edch_EventTriggerList[diagIdx]))
  {
    Edch_EventTriggerEnd = Edch_EventTriggerList[diagIdx].prev;
  }
  if(Edch_EventTriggerList[diagIdx].next != NULL_PTR)
  {
    Edch_EventTriggerList[diagIdx].next->prev = Edch_EventTriggerList[diagIdx].prev;
  }
}

/* !LINKSTO EDCH_349, 2
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Description of function Edch_CheckMuxImmeFeedback
 *
 * Check the transmission aknowledment of the ST_DIAG_OBD ALIVE signal.
 *
 * \global Edch_SendCyclic_ctrl
 *
 * \param[in] --
 * \param[out] --
 *
 * \return --
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
EDCH_STATIC FUNC(Std_ReturnType, EDCH_CODE) Edch_CheckMuxImmeFeedback
(
  void
)
{
  Std_ReturnType MuxImmeFeedback;

  if(Edch_SendCyclic_ctrl.lastImme == EDCH_IMME_INVALID)
  {
    MuxImmeFeedback = RTE_E_TRANSMIT_ACK;
  }
  else if(Edch_SendCyclic_ctrl.lastSendError != RTE_E_OK)
  {
    MuxImmeFeedback = RTE_E_COM_STOPPED;
  }
  else
  {
    MuxImmeFeedback = Rte_Feedback_ST_DIAG_OBD_MUX_IMME();
  }
  
  return MuxImmeFeedback;
}

/* !LINKSTO EDCH_364, 1
 */
#ifdef EDCH_DIAGNOSTICS_MONITOR_EN_API
/* !LINKSTO EDCH_363, 1
 */
/*----------------------------------------------------------------------------*/
/**
 * \brief Edch_MonitorEnableStatusIN
 *
 * This function is called by an User SWC. Within this function it is possible
 * to update the monitor enable status bit depending on the event index.
 *
 * \global_r  Edch_Diagnostics_Number
 * \global_rw Edch_sendIpduData
 * \global_rw Edch_EventTriggerList
 * \global_rw Edch_EventTriggerEnd
 *
 * \param[in]     IndexIN Index of incoming event
 * \param[in]     MonitorEnableStatus enable or disable the monitor enable status
 *
 * \retval E_OK     called function ends successful
 * \retval E_NOT_OK called function ends with errors
 *
 * \pre --
 *
 * \post --
 *
 * \remarks --
 *
 */
/*----------------------------------------------------------------------------*/
/* Deviation MISRA-3 <+3> */ /* PRQA S 1330 3 */
FUNC(Std_ReturnType, EDCH_CODE) Edch_MonitorEnableStatusIN
(
   Edch_EventIdxType IndexIN,
   Boolean MonitorEnableStatus
)
{
  boolean currentMonitorEnableStatus;
  Std_ReturnType retVal = E_NOT_OK;
  
  /* !LINKSTO EDCH_365, 1
   */
  if(Edch_Initialized == TRUE)
  {
    if((EDCH_GET_DIAGIDX_FLAGORDER(IndexIN, EDCH_MONITOR_ENABLED_STATUS_BITORDER)) != 0U)
    {
      /* MonitorEnableStatus is enabled */
      currentMonitorEnableStatus = TRUE;
    }
    else
    {
      /* MonitorEnableStatus is disabled */
      currentMonitorEnableStatus = FALSE;
    }

    if((MonitorEnableStatus ^ currentMonitorEnableStatus) != 0U)
    {
      /* The event status has changed */
      /* Update MonitorEnableStatus */
      /* !LINKSTO EDCH_366, 1
       */
      EDCH_SET_DIAGIDX_FLAGORDER_VAL(IndexIN, EDCH_MONITOR_ENABLED_STATUS_BITORDER, (uint8)MonitorEnableStatus);

      Rte_Enter_ExclusiveArea_0();
      if(Edch_EventTriggerList[IndexIN].marker != EDCH_REPORT)
      {
        /* put on the end of the event trigger list */
        Edch_EventTriggerEnd->next = &Edch_EventTriggerList[IndexIN];
        Edch_EventTriggerList[IndexIN].prev = Edch_EventTriggerEnd;
        Edch_EventTriggerEnd = &Edch_EventTriggerList[IndexIN];
        Edch_EventTriggerEnd->next = NULL_PTR;
        Edch_EventTriggerEnd->marker = EDCH_REPORT;
      }
      Rte_Exit_ExclusiveArea_0();
    }
    retVal = E_OK;
  }
#if (EDCH_DEV_ERROR_DETECT == STD_ON)
  else
  {
    /* !LINKSTO EDCH_365, 1
     */
    /* The following Rte-call only returns value E_OK */
    (void)Rte_Call_DetServicePort_ReportError
        (EDCH_INSTANCE_ID, EDCH_SID_MONITORENABLESTATUS, EDCH_E_INIT);
  }
#endif
  return retVal;
}
#endif


#define EDCH_STOP_SEC_CODE
#include "MemMap.h"

/*==================[end of file]=============================================*/

